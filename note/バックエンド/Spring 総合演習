■総合演習１ ～RestController  ～
・@RestController
  @Controller アノテーションと @ResponseBody アノテーションを組み合わせたもの
  @ResponseBodyとは、メソッドが返す値をHTTPレスポンスのボディとして直接書き込むことを示す。
  RESTful URLを制御するためのコントローラーを定義します。
  RESTful URL とは、REST（Representational State Transfer）アーキテクチャに基づいて設計されたURLパターン。
  本来はJSONやXMLなどを返すものですが、この場合はレスポンスとして文字列をそのままブラウザへ返します。










■総合演習２ ～ クエリ文字列とURLパス変数 ～
・クエリ文字列をGETで受ける記述
  http://localhost:8080/greet1?name=ishii&language=japanese 
	@GetMapping("/greet1")
	public String sayGreet1(@RequestParam("name") String nameA,
                    			@RequestParam("language") String languageA) {

・URLパス変数をGETで受ける記述
  http://localhost:8080/greet2/ishii/japanese
  @GetMapping("/greet2/{name}/{language}")
	public String sayGreet2(@PathVariable("name") String nameA,
	                    		@PathVariable("language") String languageA) {

・POSTの時は？
  POSTはリクエストボディにデータが含まれる事が多いため
  クエリ文字列やURLパスは補助的に扱われるらしい？
  formで送られる例は総合演習３を参照。

・先頭を大文字、2文字目以降を小文字に変換。switchで切り分け。
  nameA = nameA.substring(0, 1).toUpperCase()
      + nameA.substring(1).toLowerCase();
  languageA = languageA.substring(0, 1).toUpperCase()
      + languageA.substring(1).toLowerCase();

  switch (languageA) {
  case "Japanese":
    return nameA + "さん、こんにちは！";

  case "English":
    return "Hi, " + nameA + ". Good afternoon.";
  default:
    return "Hi, " + nameA + ". I don't know about " + languageA + ".";
  }











■総合演習３ ～ 静的コンテンツと動的コンテンツ ～
・静的コンテンツ(HTML, CSS, JS, 画像など固定の内容)の配置場所
  src/main/resources/static
  ファイル名に直接アクセス。
  ※Eclipse は resources フォルダの内容を target/classes フォルダの配下に自動コピーし
  プロジェクト実行時は target フォルダ配下のファイルを参照する。
  Eclipse の不具合で自動コピーをミスる場合、手動でstaticフォルダ事コピーする。

・動的コンテンツ(動的に生成されるHTML)の配置場所
  src/main/resources/templates
  コントローラ経由でアクセス。

・formからPOSTを受け取る例
  <form action="/greet3" method="post">
    <input type="text" name="name属性名" placeholder="案内用文字列">
    <input type="submit" value="送信">
  </form>
  ----------------------------------------------------------------
  @PostMapping("/greet3") 
  public String sayGreet(@RequestParam("name属性名") String nameA) { 
    return nameA + "さん、こんにちは！"; 
  } 
  入力フィールドが空の時はplaceholderの値が薄く表示され視覚的にわかりやすい。
  ※placeholderはテキスト入力を伴うtypeなら殆ど使える。










■総合演習４ ～ ModelとModelAndView ～
・ThymeleafのURI (おまじない的な物)
  <html xmlns:th="http://www.thymeleaf.org"> 
  これは実際にアクセスするための物ではなく、Thymeleafの名前空間のURIである。
  HTMLやXMLテンプレート内でThymeleaf専用の属性（例: th:text, th:if）を使用する際
  HTML属性と混同されずにThymeleafのテンプレートエンジンが正しく解釈できるようなる。

・大前提の知識
  ModelやModelAndViewにデータペアを格納するのはビューで利用するため。

・ModelAndView
  Model(データペア)とビュー名の両方を1つのオブジェクトに格納して戻り値で返す。
  @Controller
  public class GreetController {
	  @PostMapping("/greet4")
	  public ModelAndView sayGreet(@RequestParam("name") String name,ModelAndView modelAndView) {
  	    modelAndView.setViewName("greet_thymeleaf"); //ビュー名を指定
		    modelAndView.addObject("name", name); //データペアは ("キー" , 値) で設定。
		  return modelAndView;//ビュー名とデータペアを格納したオブジェクトを返す。
    }
  }
  いきなり出てきた引数「ModelAndView modelAndView」は送り元のFormに記載されていない値。
  この引数の記述をトリガーにSpringが内部的にインスタンス生成しメソッドに渡している。
  だから引数にいきなり記述してもちゃんと受け取る事が出来る。
  Spring は「ビューリゾルバ」という仕組みを使用しビュー名（greeting）を
  テンプレートファイル（例:greeting.html や greeting.jsp）に変換する。
  つまり、このビュー名に対応するファイルを作成する必要がある。
  作成したビューファイルに対してModelAndViewのデータペアが渡される。
  @PostMapping("/greet4")
  public ModelAndView sayGreet(@RequestParam("name") String name) {
      ModelAndView modelAndView = new ModelAndView("greet_thymeleaf"); //ビュー名指定。
      modelAndView.addObject("name", name); //データペアは ("キー" , 値) で設定。
      return modelAndView; //ビュー名とデータペアを格納したオブジェクトを返す。
  }
  引数に記述しなければインスタンスは自動生成されない。
  戻り値型をModelAndViewにして、メソッド内で手動でインスタンス生成も可能。
  同じ結果になるが、Springを知らない人からしたら可読性はこちらの方が高い。

・Model
  ModelAndViewとは違い、データペア(キー&値)をModelに格納し、ビュー名は戻り値で返す。
  public String sayGreet(@RequestParam("name") String name, Model model) {
    model.addAttribute("キー名", name);//データペアは ("キー" , 値) で設定。
    return "greeting"; //戻り値でビュー名を指定
  }
  このビュー名はModelAndViewの時と同じようにビューリゾルバでhtmlやjspに変換される。 
  つまり、このビュー名に対応するファイルを作成する必要がある。
  作成したビューファイルに対してModelのデータペアが渡される。

・テンプレートファイル
  サーバサイドの処理データが埋め込まれる事で完成するファイルのこと。
  Thymeleafエンジンが「プレースホルダーの${name}」や「th:text」を解釈しHTML/JSPに埋め込む。
  HTMLファイルを「次で開く→Webブラウザ」とした場合はエンジンを返さないでアクセスする。
  下記の記述だと、th:text="${name}"が解釈されないため、通常のHTML部分のみが表示される。
  <span style="color:red" th:text="${name}">通常のHTMLで表示される領域</span>
  ※解釈された際は上書きされるため「通常のHTMLで表示される領域」は表示されない。
  
・テンプレートファイルの引継ぎ(ビューリゾルブ)
  @RestController
  これは@Controllerと@ResponseBodyを組み合わせたアノテーション。
  @ResponseBodyによりメソッドの戻り値は直接「HTTPレスポンスのボディ」に返される。
  そのため、ビューリゾルブ(テンプレート検索・HTML/jspへの変換)が発動しない。
  主に RESTful API を構築する際に使用するらしい。
  ---------------------------------------
  @RestController
  public class GreetController {
      @GetMapping("/greet")
      public String greet() {
          return "こんにちは、世界！";
      }
  }
  ---------------------------------------
  例：「こんにちは、世界！」は greetのレスポンスボディに書かれる。
  
・レスポンスボディ
  HTTPレスポンスの一部でサーバーがクライアントに返すデータの本体部分のこと。
  混同しやすいが、「HTMLの<body>タグとは異なる」ので注意。
  APIを使ってJSONデータを返す場合や、HTMLページを返す場合などにこの部分が利用される。
  ・APIレスポンス: サーバーがJSONデータを返す場合
    レスポンスボディには、JSON形式のデータ（例えば、{"name": "John", "age": 30}）が入る。
  ・HTMLレスポンス: サーバーがHTMLページを返す場合
    レスポンスボディには、HTML全体（<html>...</body>）が入る。

  @Controller
  ビューリゾルブ(テンプレート検索・HTML/jspへの変換)が発動して
  メソッドの戻り値として指定されたビュー名（たとえば greeting）を基に
  テンプレートエンジンがテンプレートファイル（greeting.htmlなど）を検索し
  レンダリング(解釈を注入してビューを生成)する。
  Spring Boot などの標準設定では、ThymeleafやJSPのビューリゾルバが自動的に設定されるが
  @Controllerを使う場合、ビューリゾルバが適切に設定されていないとビュー解決できない。
  Thymeleafの場合「spring-boot-starter-thymeleaf」を依存関係に含めることで自動的に設定される。
  ※Spring Bootの自動設定機能でMavenやGradleを選択後にプロジェクト作成すると追加される。
  
・Maven(メイヴン)で「spring-boot-starter-thymeleaf」が設定されているか確認。
  ルートディレクトリのpom.xml に以下が追加されていること。
  <dependency> //デペンデンシー：依存関係
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-thymeleaf</artifactId>
  </dependency>

・Gradle(グラドル)で「spring-boot-starter-thymeleaf」が設定されているか確認。
  ルートディレクトリのbuild.gradle に以下が追加されていること。
  implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'

・MavenとGradleはビルドツール
  ソフトウェアの開発において作業を効率的に行うためのツール。
  下記の作業が自動化され、手動よりもエラーを減らし効率を高める。
  ・依存関係の管理
    外部ライブラリやフレームワークをプロジェクトに追加する際
    その依存関係を自動でダウンロード・管理します。
    Maven：~/.m2/repository  に依存関係を格納し、プロジェクトごとに個別のライブラリが保存される。
    Gradle：~/.gradle/caches に依存関係をキャッシュし、他のプロジェクトでも共通して使えるようにする。
    ※~はローカルのユーザフォルダ。
  ・コンパイル
    ソースコードをコンパイルしてバイナリ形式（例えば、.classファイルや.JARファイル）に変換。
  ・テストの実行
    単体テストや統合テストを自動で実行し、テスト結果をレポートとして出力する。
  ・パッケージ化
    完成したコードをJAR、WARなどの形式でパッケージ化する。
    これにより、プロジェクトを他のシステムにデプロイしやすくなる。
  ・デプロイ
    完成したソフトウェアを指定したサーバーや環境に自動的にデプロイ（配置）します。

・MavenとGradleの違い
  +-------------------+-------------------------------------------+--------------------------------------------+
  | 特徴              | Maven                                     | Gradle                                     |
  +-------------------+-------------------------------------------+--------------------------------------------+
  | 設定ファイル       | `pom.xml`（XML形式）                     | `build.gradle`（GroovyまたはKotlin DSL）   |
  +-------------------+-------------------------------------------+--------------------------------------------+
  | 依存関係管理       | リモートリポジトリから依存関係を管理     | 同様にリモートリポジトリから依存関係を管理 |
  +-------------------+-------------------------------------------+--------------------------------------------+
  | パフォーマンス     | 比較的遅い（ビルドキャッシュなし）       | 高速（インクリメンタルビルドや並列処理）   |
  +-------------------+-------------------------------------------+--------------------------------------------+
  | カスタマイズ性     | 制約がある（宣言的）                     | 高い（プログラム的なカスタマイズが可能）   |
  +-------------------+-------------------------------------------+--------------------------------------------+
  | 学習曲線           | 初心者でも比較的簡単に始められる         | 少し学習曲線がある（特にカスタマイズ時）   |
  +-------------------+-------------------------------------------+--------------------------------------------+
  | ビルドスクリプト   | 宣言的（XMLによる設定）                  | プログラム的（GroovyやKotlinによる設定）   |
  +-------------------+-------------------------------------------+--------------------------------------------+











■総合演習５ ～ タイムリーフ ～
input.htmlのform→コントローラ→result.htmlにタイムリーフでデータを埋め込んでいる。
table border="1"はテーブル定義＆薄い罫線を引くという意味。
trは1行、tdは行の1セルを示している。
th:text="${language}"でタイムリーフによってlanguage属性の値を表示する。
----------------------------------------------------------------------
<!DOCTYPE html> 
<html xmlns:th="http://www.thymeleaf.org"> 
～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
<table border="1"> 
        <tr> 
                <td>言語</td> 
                <td> 
                        <span th:text="${language}"></span> 
                </td> 
        </tr>
</table> 
----------------------------------------------------------------------









■総合演習６ ～ バインドとバリデーション ～
・コントローラ
  HTTPリクエストを受け取り、必要なデータをModelオブジェクトに格納する。
  その後、ビュー名（例えば、Thymeleafテンプレートの名前）を返す。

・model
  コントローラからビューに渡されるデータをModelオブジェクト追加することで後にビューでデータを使用できる。
  このModelを一時的に保存しておくのがリクエストスコープ。
  GETやPOSTリクエストで引数としてModelのデータをメソッドに渡し、メソッド終了後にリクエストスコープは破棄される。

・ビュー
  コントローラから渡されたModelのデータをタイムリーフで参照しHTMLを動的に生成、表示する。

・バインド
  フォームの入力値とBeanのプロパティをリンクさせる仕組み。
  入力値をサーバーサイドのオブジェクトに簡単に格納できるし
  オブジェクトの値をフォームの初期値として表示できる。
  後にやるバリデーションを行うのにも必要。

・フォームバッキングオブジェクト
  簡単に言えば、フォームバッキングオブジェクトはフォーム操作に特化したBeanのこと。
  バッキングとはバックエンドの支援や支持という意味がある。

・バインドの流れ
  formからのHTTPリクエストをコントローラで受ける。
  コントローラがBeanオブジェクトをインスタンス化しModelに格納、そのビューをブラウザに返す。
  --------------------------------------------------------------------------------------
  // フロントサイド、form内でのバインド
  <form th:object="${user}" th:action="@{/updateUser}" method="post">
    <input type="text" th:field="*{username}">
    <button type="submit">Update</button>
  </form>
  // ※この処理ではFormの入力値をBeanのプロパティにバインドさせる「準備」を行う。
  // 入力値がBeanのプロパティに反映されるのはサーバサイドで行うので注意。
  // th:object は、フォーム全体を特定のbeanにバインドするために使用。
  // th:field は、個別のフォーム要素を、th:objectでバインドしたbeanの特定のプロパティにバインドするために使用。
  // *{}にはbeanのプロパティを指定、プロパティ名のみでよいのはth:objectでフォーム全体をバインドしているから。
  // th:objectとth:fieldは「input,select,option,textarea」のタグ内に付与できる。
  --------------------------------------------------------------------------------------
  // サーバサイド、コントローラでバインド(@ModelAttribute使用)
  @PostMapping("/updateUser")
  public String updateUser(@ModelAttribute("user") User user) {
      // from→Userにバインドされた情報を使って処理を行う
      System.out.println("Updated Username: " + user.getUsername());
      // 処理後にリダイレクトや別のページに遷移
      return "redirect:/userProfile"; // 更新後にユーザープロファイルページへリダイレクト
  }
  // 2行目の@ModelAttribute("user")でバインド情報とbeanインスタンスuserをUser userで受取っている。
  // @ModelAttributeが動作するタイミング(メソッド呼び出し前)にフォーム入力値がbeanプロパティに代入される。
  // この仕組みをform-backing-beanという。
  ---------------------------------------------------------------------------------------

・バリデーションが完了するまでの流れ
  ・formからPOST(この時点でフロント側の入力チェックは後回しにされる)
  ・コントローラでデータバインディング(form入力値とBeanのプロパティがリンクされる)
  ・Bean内のバリデーションでエラーが見つかったら、BindingResultに格納(バックエンド側の入力チェック)
  ・Thymeleafによるエラーメッセージの表示(フロント側の入力チェック)
   (バリデーションの結果、エラーが存在する場合に、Thymeleafテンプレートが動的にエラーメッセージを表示)
   ※この例に限らず、基本Thymeleafは最後に処理される。
 
・コントローラの処理
  @PostMapping("/register") 
  public ModelAndView registerGreet( 
        @ModelAttribute @Validated GreetForm greetForm, //第１引数 バインド済のBeanを受け取る。
        BindingResult result,                           //第２引数 エラー格納用のresultが自動生成される。
        ModelAndView modelAndView                       //第３引数 modelAndViewが自動生成される。
        ) {
        //  入力されたデータのバリデーションエラーチェック 
        if (result.hasErrors()) {  //エラー有無を判定するBindingResultのメソッド
          modelAndView.setViewName("input"); //エラー有りならmodelにinputビューをセット。
          return modelAndView; //オブジェクトを返し、beanとresultのリクエストスコープを破棄。
        }
  }
  -@ModelAttributeのクラス名省略----------------------------------------------------------------------------
  // まず、第１引数で「@ModelAttribute("greetForm")」が省略され、「@ModelAttribute」になっている点に注意。
  // Springは引数のオブジェクトのクラス名（最初の文字を小文字に変えたもの）をデフォルトの名前として使用。
  // つまり、省略すると自動的にGreetForm→greetFormが使われる。わかりにくい！！！
  -@Validated-----------------------------------------------------------------------------------------------
  // @Validatedは受け取ったバインド済Bean(GreetFormクラス)の入力データの検証を有効するアノテーション。
  // Bean内にバリデーション処理が記述されている場合、このアノテーションがトリガーとなる。
  // 付与し忘れても構文エラーにはならないが、バリデーションが起動せずにBindingResultは空のままになる。
  // 第2引数 BindingResultは検証結果を受け取るためのオブジェクトで検証エラー情報が格納される。
  // このオブジェクトは引数に設定したら自動的にオブジェクトが生成される。
  // ※BindingResult引数は@Validated引数の次に定義しなければいけない。 
  // 検証エラーの有無は BindingResult オブジェクトの”hasErrors()”メソッドで判定。 
  ----------------------------------------------------------------------------------------------------------

・beanのエラーチェック、messageとデフォルトエラーメッセージ（バックエンド側の入力チェック）
  ------------------------------------------------------------------------------------
	@NotNull
	@Size(min = 1, max = 20, message = "言語は１文字以上２０文字以下で指定してください")
	private String language;
  // アノテーションは複数付与できるが、カスタムメッセージ(message)はアノテーション毎に設定。
  // @NotNullだけだと、message未設定のためデフォルトのエラーメッセージが発生するらしいが確認できず。
  // @Sizeのmessageを削除したらデフォルトエラーメッセージの発生を確認出来た。
  ------------------------------------------------------------------------------------

・バリデーションアノテーションについて
  beanに記述するアノテーション、ここでバインドした意味が出てくる。
  formから入力した値がbeanのフィールドに代入される時に
  下記のアノテーションによって入力値がチェックされる。
  異常値の場合はエラーメッセージを発生させたり出来る。
  +-----+---------------------------+---------------------------------+
  | No. | 検証項目                  | アノテーション                  |
  +-----+---------------------------+---------------------------------+
  | 1   | 必須フィールドのチェック  | @NotNull, @NotEmpty, @NotBlank  |
  | 2   | 最小値と最大値のチェック  | @Min, @Max                      |
  | 3   | 文字列の長さのチェック    | @Size                           |
  | 4   | 正規表現のチェック        | @Pattern                        |
  | 5   | 日付の妥当性のチェック    | @Past, @Future                  |
  | 6   | 配列などのサイズチェック  | @Size                           |
  +-----+---------------------------+---------------------------------+

・formのtd内でエラーチェック。（フロント側での入力チェック）
    コントローラでバインドされたデータがビューに渡される時、BindingResultのエラー情報も渡される。
    BindingResult に格納されたエラー情報を基にThymeleafテンプレート内でエラーメッセージを表示する。
    つまり、バックエンド側でのエラーチェック後にフロント側のエラーチェックが流れるということ。
    ------------------------------------------------------------------------------------
    <td><input type="text" name="language" th:field="*{language}"</td>
    <td  th:if="${#fields.hasErrors('language')}" th:errors="*{language}" style="color : red"></td>
    // th:fieldを使用すると、Thymeleaf は自動的に#fieldsオブジェクトを生成する。
    // #fieldsのhasErrorsでlanguageプロパティにエラーがあるか判定。※
    // エラーならth:errors="*{language}"でlanguageプロパティに対するエラーメッセージを表示。
    ------------------------------------------------------------------------------------











■総合演習７ ～ フィールドインジェクションによるDI (Spring未使用) ～
----------------------------------------------------------------------------
try {
    Field field = GreetController.class.getDeclaredField("greetService");
    field.setAccessible(true);
    field.set(greetController, greetServiceJapanese);

    //	日本語の挨拶
    System.out.println("*****  日本語サービスを注入します  ****");
    System.out.println("朝の挨拶：" + greetController.sayOnMorning());
    System.out.println("昼の挨拶：" + greetController.sayOnNoon());
    System.out.println("夕方の挨拶：" +	greetController.sayOnEvening());
    System.out.println("夜の挨拶：" + greetController.sayOnNight());
    
    } catch (NoSuchFieldException | IllegalAccessException e) {
    e.printStackTrace();
}
------------------------------------------------------------------------------------------
Field field = GreetController.class.getDeclaredField("greetService")
・Field
  「java.lang.reflect.Field」をインポートすると使用できるクラス。
    リフレクションで取得したクラスのフィールドのメタ情報を格納しアクセス修飾子無視で操作するクラス。
・getDeclaredField("フィールド名")
    classのメソッドでこれもアクセス修飾子無視でクラスフィールドのメタ情報を取得。
    例では、GreetControllerクラスのprivateフィールド「greetService」を取得している。
・field.setAccessible(true)
    fieldに格納されたフィールドの値は、アクセス修飾子が有効なのでこのままだと他クラスがアクセス不可。
    だから、field.setAccessible(true) でアクセスを制限を解除している。
・間違えやすいポイント
  ※「取得したのはクラスのフィールドのメタ情報」で「実際のインスタンスのフィールドの値」ではない。
  ※実際にインスタンスのフィールドの値を操作するには、field.set(インスタンス名,値)を使用する。
------------------------------------------------------------------------------------------

■リフレクション・Classについて
・Javaのリフレクション（反射）機能に関連するクラスです。
・全てのクラスはそのクラスのClassオブジェクトを持っている。
  オブジェクトの中身はメタデータと呼ぶ「クラス名・コンストラクタ・メソッド・フィールド等」
・オブジェクトを通じてメタデータにアクセスしたり、インスタンスを動的に生成したりできる。

①クラスオブジェクトを取得
  Class<?> clazz = InjectionSampleApplication.class;  // クラスオブジェクトを取得

②クラス名の取得
  Class<?> clazz = SomeClass.class;
  String className = clazz.getName();  // クラス名を取得
  System.out.println("クラス名: " + className);// クラス名を表示

③コンストラクタの取得
  Class<?> clazz = SomeClass.class;
  Constructor<?> constructor = clazz.getConstructor(String.class);  // 引数にStringを取るコンストラクタ
  // SomeClassのStringを引数に取るコンストラクタを取得する。

④フィールドへのアクセス
  Class<?> clazz = SomeClass.class;
  Field field = clazz.getDeclaredField("someField");  // フィールドの取得
  field.setAccessible(true);  // 非公開フィールドにアクセスする場合
  Object value = field.get(someObject);  // フィールドの値を取得
  field.set(someObject, newValue);  // フィールドの値を変更

⑤メソッドの取得と呼び出し
  Class<?> clazz = SomeClass.class;
  Method method = clazz.getMethod("someMethod", String.class);  // 引数にStringを取るメソッド
  method.invoke(someObject, "Hello");  // メソッドを呼び出す

⑥取得したコンストラクタを使いインスタンスを生成
  Class<?> clazz = SomeClass.class;
  Object instance = clazz.getDeclaredConstructor().newInstance();  // 引数なしのコンストラクタでインスタンス生成

■Fieldクラスのメソッド
+-----------------------------------+----------------------------------------------------+
| メソッド                          | 説明                                               |
+-----------------------------------+----------------------------------------------------+
| getName()                         | フィールドの名前を取得                             |
| getType()                         | フィールドの型を取得                               |
| getDeclaringClass()               | フィールドが属するクラスを取得                     |
| getModifiers()                    | フィールドの修飾子（アクセスレベルなど）を取得     |
| setAccessible(boolean flag)       | アクセス制限を解除（privateやprotectedフィールド） |
| get(Object obj)                   | 指定したオブジェクトのフィールドの値を取得         |
| set(Object obj, Object value)     | 指定したオブジェクトのフィールドに値を設定         |
| getBoolean(Object obj)            | フィールドがboolean型の場合、その値を取得          |
| getByte(Object obj)               | フィールドがbyte型の場合、その値を取得             |
| getChar(Object obj)               | フィールドがchar型の場合、その値を取得             |
| getDouble(Object obj)             | フィールドがdouble型の場合、その値を取得           |
| getFloat(Object obj)              | フィールドがfloat型の場合、その値を取得            |
| getInt(Object obj)                | フィールドがint型の場合、その値を取得              |
| getLong(Object obj)               | フィールドがlong型の場合、その値を取得             |
| getShort(Object obj)              | フィールドがshort型の場合、その値を取得            |
| setBoolean(Object obj, boolean z) | boolean型の値をフィールドに設定                    |
| setByte(Object obj, byte b)       | byte型の値をフィールドに設定                       |
| setChar(Object obj, char c)       | char型の値をフィールドに設定                       |
| setDouble(Object obj, double d)   | double型の値をフィールドに設定                     |
| setFloat(Object obj, float f)     | float型の値をフィールドに設定                      |
| setInt(Object obj, int i)         | int型の値をフィールドに設定                        |
| setLong(Object obj, long l)       | long型の値をフィールドに設定                       |
| setShort(Object obj, short s)     | short型の値をフィールドに設定                      |
+-----------------------------------+----------------------------------------------------+










■総合演習８ ～ SpringによるDI ～
------------------------------------------------------------------------------------------------------------------
■環境変数 SPRING_PROFILES_ACTIVE
   @Profile("プロファイルグループ名") アノテーションで記載した文字列を設定する。
   SPRING_PROFILES_ACTIVEは、実行中のアプリケーションに対してどのプロファイルを有効にするかを指定する。
   プロファイルは1つしか指定出来ない（default、English、German など）
   @Profile アノテーションを使用して、特定のプロファイルに関連付けられたBean（コンポーネント）を定義。
   プロファイルグループ名を本番用とテスト用で分けて、環境変数でどちらを使うか指定すれば一括でON/OFF出来る。
   どのDBを使用するかを設定するファイルを選ぶ際にも使える。
   application-{プロファイル名}.properties
   application-test.properties
   application-product.properties
   プロファイル名を変更すれば接続するDBを切り替える事が出来る。

■SPRING_PROFILES_ACTIVEの設定方法
  ①ターミナル使用
    エクリプスより優先される。
    SpringBootをコマンドライン起動する際に環境変数も設定する方法。
    例：SPRING_PROFILES_ACTIVE=English java -jar myapp.jar
    これは一時的な設定なので、毎回入力する必要があるが、IDEに依存しないためどこでも利用可能。
  ②エクリプスの「実行R」＞「実行構成」使用
    IDEの実行に限定されるので注意、エクリプス外のサーバやアプリケーションや端末では無効になる。

■設定方法による違い
+-------------------------+-----------------------------------------------+-----------------------------------------------+
| 項目                    | エクリプス「実行構成」で設定する環境変数      | コマンドラインで SPRING_PROFILES_ACTIVEを設定 |
+-------------------------+-----------------------------------------------+-----------------------------------------------+
| 設定方法                | エクリプスの実行構成ダイアログで設定          | ターミナルで環境変数を設定しアプリ実行        |
+-------------------------+-----------------------------------------------+-----------------------------------------------+
| 適用範囲                | エクリプス内での実行にのみ適用                | コマンドライン実行orサーバー/CI/CDで適用される|
+-------------------------+-----------------------------------------------+-----------------------------------------------+
| 柔軟性                  | 特定の実行構成に依存                          | より汎用的で、サーバーや他の環境でも使用可能  |
+-------------------------+-----------------------------------------------+-----------------------------------------------+
| 永続性                  | 実行構成ごとに保存、エクリプス内で再利用可    | 実行時の一時的な設定として、終了後に無効になる|
+-------------------------+-----------------------------------------------+-----------------------------------------------+
| 複数のプロファイルの設定 | 設定可能(SPRING_PROFILES_ACTIVE=English,Test)| 同様に設定可能（, で区切る）                  |
+-------------------------+-----------------------------------------------+-----------------------------------------------+

■Springを利用したコンストラクタインジェクション
------------------------------------------------------------------------------------------------------------
@Controller //このアノテーションがついているクラスはSpring起動時に自動でインスタンス化される。
public class GreetController {
	private final GreetService greetService;

  @Autowired
	public GreetController(GreetService greetService) {
		this.greetService = greetService;
	}
  // コンストラクタが1つの場合は@Autowiredを省略可能。
  // さらに、今回は
	// 引数のGreetServiceはインタフェースなので実装クラスが検索される。
	// 今回GreetServiceを実装してる＆@Serviceが付いているクラスは3個ある
	// @Profileで環境変数にしていされているクラスが選ばれる。
～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～

■th;objectを使うか否か
①バインドなし(th:object不使用) 表示させるだけならこれで十分
  @GetMapping("/greet")
  public ModelAndView greet(ModelAndView modelAndView) {
      String language = greetService.language();
      modelAndView.setViewName("greet");
      modelAndView.addObject("language", language);
      modelAndView.addObject("message", ""); // 空のメッセージ
      return modelAndView;
  }
  --------------------------------------------------------------
  <h2>世界の挨拶</h2>
  <div>
      <span>言語 ： </span>
      <span th:text="${language}"></span> <!-- 言語を表示 -->
      <br />
      <h3>
          <span>挨拶：</span>
          <span th:text="${message}"></span> <!-- メッセージを表示 -->
      </h3>
  </div>
  ---------------------------------------------------------------

②フォームバインディング(th:object) バックエンドで処理させたい時に使う(バリデーション等)
  @PostMapping("/submitForm")
  public String submitForm(@ModelAttribute("user") User user) {
      // userオブジェクトを処理
      return "formResult";
  }
  ---------------------------------------------------------------
  <form action="/submitForm" th:object="${user}" method="post">
      <input type="text" th:field="*{name}" />
      <input type="submit" value="Submit" />
  </form>
  ---------------------------------------------------------------









■総合演習９ ～ JPAを使って挨拶をデータベースに登録 ～
------------------------------------------------------------------------------------------------------------------
■Spring Data JPAとは
データベースとのマッピングを簡潔に行う。

■JpaRepositoryを継承したインタフェースを作るだけで基本的なCRUD処理は作成完了=DAOが出来ちゃう。
Public interface ProductRepository extends JpaRepository<Product, Integer> {
    // Product=Entity, Integer=主キーの型
    // 何も定義しなくても以下のような基本処理は使用可能
}
--------------------------------------------------------------------------------

メソッド             | 引数              | 戻り値             | 説明
---------------------|-------------------|--------------------|-------------------------------------------
findAll()            | なし              | List<T>            | すべてのレコードを取得
findById()           | キー              | Optional<T>        | キーに該当するレコードを取得
getById()            | キー              | T                  | キーに該当するレコードを取得
count()              | なし              | long               | レコード数を取得
existsById()         | キー              | boolean            | キーに該当するレコードが存在するかを取得
save()               | T                 | T                  | キーが存在する場合は更新、存在しない場合は登録 UPDATEとinsertが両方使える面白いメソッド
saveAll()            | List<T>           | List<T>            | Entity の数だけsave()を実行
deleteById()         | キー              | なし               | キーに該当するレコードを削除
deleteAllById()      | List<キー>        | なし               | キーの数だけdeleteById()を実行

■@Query 複雑なクエリ分を生成する
  // JPQLによる定義
  // この記述は特定のデータベースに依存しない定義。
  @Query("select u from User u where u.age = :age")
  List<User> myFindByAge(int age);
  // ネイティブクエリによる定義
  // こちらはデータベースに依存することになるので移行が困難になるので注意。
  @Query(value = "select * from user where age = ?1", nativeQuery = true)
  List<User> myFindByAge(@Param("age") int age);

■メソッド名からクエリ文を自動生成
Public interface ProductRepository extends JpaRepository<Product, Integer> {
// Product=Entity, Integer=主キーの型
// インタフェースを定義するだけで独自のCRUD処理が可能
  List<Product> findByNameContainig(String keyword);
}
--------------------------------------------------------------------------------
メソッド命名ルール
※以下の３つの要素を規則に従って組み合わせる。
・プレフィックス（find...By / exists...By / delete...By / count...By / get...By など）
  名前の出だしで動作決まる。

・キーワード(Not / And / Or / LessThan / GreaterThan / OrderBy / Distinct など)
  検索条件や並べ替え条件などを決める。

・フィールド名
  Entityのフィールド名をパスカル形式で記述する。
  ※パスカル形式
  最初の文字が大文字になる。
  以降の単語の最初の文字も大文字にし、他の文字は小文字にする。
  単語と単語の間にスペースやアンダースコアなどは入れない。
  ＜例＞
  LastnameとFirstnameを引数で指定された値で検索し、その結果をAgeで降順にソートする
  これは例なので実際は""は記述しない、このキーワードが入ってるか否かで判断される。
  "findBy"Lastname"And"Firstname"OrderBy"Age"Desc"(String lastname, String firstname)

・Entity（エンティティ）
  データベースと連携してデータを操作するためのJavaクラスのこと。
  JPA（Java Persistence API）を使ってデータベースにアクセスする際
  エンティティクラスはデータベースのテーブルと対応します。
  エンティティは、データベースのテーブルの行（レコード）を表現し
  オブジェクト指向の形式でデータを管理するために使います。

・@SuppressWarnings("null")アノテーション
  コンパイラに対して「nullに関する警告を無視するように指示するもの」です。

・JPAの利用はインタフェースを継承するだけで使えるって話のやつ
  public interface GreetRepository extends JpaRepository<GreetMessage, Integer> {
	public GreetMessage findByLanguage(String language);
	public List<GreetMessage> findAll();
}
------------------------------------------------------------------------------------


mysql> select * from greet_message;
+----+----------+--------------------+------------+------------+----------------+---------+
| id | language | morning            | noon       | evening    | night          | remarks |
+----+----------+--------------------+------------+------------+----------------+---------+
|  1 | 日本語   | おはようございます | こんにちは | こんばんは | おやすみな さい | NULL    |
+----+----------+--------------------+------------+------------+----------------+---------+

・findByLanguageはSQL：SELECT * FROM greet_message WHERE language = ?;
  →?はメソッド引数であるlanguageに対応、これはプレースホルダーを利用している時と同じ。
  Spring Data JPAは自動的にSQLインジェクションのリスクを軽減している。
  このコマンドは"languageに一致する最初の行（レコード）"を取得できる。
・findAllですべてのレコード(全行)を取得SQL：SELECT * FROM greet_message
  findByLanguageでGreetMessage(１行分しか入ってないけど)の全行を取得し"リストにしている"

■アノテーションが一気に出てきたので情報整理
@Data
@Entity
@Table(name = "greet_message")
public class GreetMessage {
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer id;
	@Column(nullable = false, unique = true)
	private String language;
	private String morning;
	private String noon;
	private String evening;
	private String night;
	private String remarks;
}

■@Entity
 付与されたクラスがJPAエンティティであることを示す。
 エンティティとはDBのテーブルと１対１でマッピングされるクラスのこと。

■@Table(name = "greet_message")
 @Tableアノテーションは、このエンティティクラスが対応するデータベーステーブルの名前を指定する。
 @Tableアノテーションはクラス名と異なるテーブル名を付ける場合指定

■@Id
 @Idアノテーションは、このフィールドがエンティティの主キー（ユニークな識別子）であることを示す。
 プライマリキーとなるプロパティを指定します。プライマリーキーを自動採番する場合は@GeneratedValueアノテーションで指定。

■@GeneratedValue(strategy = GenerationType.IDENTITY)
 主キーの値が自動的に生成されることを指定しています。
 GenerationType.IDENTITYは、データベースで自動インクリメントされる主キーを使う場合に使用します。

 ■@Column
  列名とプロパティ名が異なっていたり、Nullを許さない列だったり、同じ値を格納できない場合に使用。

■タイムリーフでリンクボタンを作る
  <a th:href="@{/delete/{id}(id=${greet.id})}">削除</a>

■タイムリーフでループ
<!-- greetMessages をループして表示 -->
<tr th:each="greet : ${greetMessages}">
    <td th:text="${greet.id}"></td>
    <td th:text="${greet.language}"></td>
    <td th:text="${greet.morning}"></td>
    <td th:text="${greet.noon}"></td>
    <td>・・省略・・</td>
    <!-- 削除確認画面に遷移 -->
    <td><a th:href="@{/delete/confirm/{id}(id=${greet.id})}">削除</a></td>
</tr>

■th:if
	<div th:if="${error != null}">
	<h3 style="color:red" th:text="${'エラー ： ' + error}"></h3>

■th:object
  divタグ内でmodelのフィールドにアクセスする際
  オブジェクト名(例：greetForm)を省略できる。
  ※省略時は$じゃなくて*になるのも地味に注意。
  ～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～
	<div th:object="${greetForm}">
  <table border="1">
    <tr>
      <td>言語</td>
      <td>
        <span th:text="*{language}"></span> //th:objectが無いと"${greetForm.language}"で長くなる。
      </td>
  ～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～～

■findById(識別子)
  greetRepository.findById(id).orElse(null)
  ・findById
    JPAがデフォルトで持ってるメソッド、戻り値は「Optional<T>」
  ・orElse(null)
    findById(id)の戻り値であるOptionalのため、Optionalのメソッドが使える。
    Optionalが値を持っている場合はその値を返し、無い場合は引数として渡したnullを返す。

  Optionalはnullを扱うメソッドを持つクラス。
  +---------------------+---------------------------------------------------------------------------------------------+
  | メソッド名          | 説明                                                                                        |
  +---------------------+---------------------------------------------------------------------------------------------+
  | of(T value)         | `null` ではない値を包む `Optional` を作成。もし`null` を渡すと`NullPointerException` が発生 |
  | ofNullable(T value) | 値が `null`かもの時 `Optional` を作成する。`value`が`null`なら`Optional.empty()` を返す。   |
  | empty()             | 中身がない `Optional` を返します。                                                          |
  | isPresent()         | 値が存在すれば `true` を返します。                                                          |
  | get()               | 値を取得。値が存在しない場合は `NoSuchElementException` をスロー（非推奨）。                |
  | orElse(T other)     | `Optional` が値を持っていればその値を返し、持っていなければ引数のデフォルト値を返す。       |
  +---------------------+---------------------------------------------------------------------------------------------+











■総合演習１０ 挨拶表示
-----------------------------------------------------------------------------------------------------------------------------------
■@GetMapping({"/", "/greet"})
 / と /greet のどちらの URL がリクエストされても同じメソッドで処理できる記述。

■■ドロップダウンリストの復習
<select id="language" name="language">
    <option value="japanese">日本語</option>
    <option value="english">英語</option>
    <option value="french">フランス語</option>
    <option value="spanish">スペイン語</option>
</select>
・selectはユーザーに複数の選択肢を提供するためドロップダウンリストやリストボックスを作成します。
・idはselectタグをcssなどで編集する際に使う。
・nameはselectタグの結果を送る際の属性。
・optionタグの内容がリスト内容になる、ここがブラウザに表示される。
・英語を選択した場合、language=englishが送られる。
・sizeが指定されていない場合は1行のドロップダウンリストが作成される。

■<selected>とは？
<select name="timeframe" size="4">
    <option value="morning" th:selected="${timeframe == 'morning'}">朝</option>
    <option value="noon" th:selected="${timeframe == 'noon'}">昼</option>
    <option value="evening" th:selected="${timeframe == 'evening'}">夕方</option>
    <option value="night" th:selected="${timeframe == 'night'}">夜</option>
</select>
このコードだと、timeframe の値が "morning" と一致している場合に<option>にselected属性が付与されます。

■初期画面が完成するまでの流れ
------------------------------------------------------------------------------
<select id="language" name="language">
  <option th:each="option : ${languageOption}" th:value="${option}"
          th:selected="${option == language}" th:text="${option}"></option>
</select>
------------------------------------------------------------------------------
まず、http://localhost:8080/greetにアクセスするとGETがコントローラーに投げられる。
ここでドロップダウンリストで使う初期値が設定される。
あと、ＤＢから言語一覧も取得する。
  @GetMapping({"/","/greet"}) //これで拾う。
  public ModelAndView greet(ModelAndView modelAndView) {
  List<String> languages=greetService.getLanguages(); //言語一覧を取得
  modelAndView.setViewName("greet");
  modelAndView.addObject("language","日本語"); //初期値を設定
  modelAndView.addObject("languageOption",languages);//言語一覧を設定
  modelAndView.addObject("timeframe","morning"); //初期値を設定
  return modelAndView; //これで初期画面が完成
  }
greet.htmlにタイムリーフで動的に取り込まれて、初期画面が完成する。

















