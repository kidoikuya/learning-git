https://gihyo.jp/book/2024/978-4-297-14049-6/support

- 1.概要 ----------------------------------------------------------------------------------------------------
■Spring
Springとはフレームワークの集合体。
含まれているフレームワークは下記。
・Spring Boot
  開発環境を整える役割、何か開発するよ！となったらまず使う機能。
・Spring Data
  データアクセス(データベース操作)機能。
・Spring MVC
  Webアプリケーションを簡単作成する機能。
・Spring Batch
  バッチ処理(自動化処理)機能。
・Spring Security
  認証／認可・セキュリティ関連機能。
・Spring Framework
  ・DI：依存性注入の機能。
  ・AOP：アスペクト指向プログラミングの機能。
・DBについてオマケ
  MySQLはOracleが買収しちゃったので完全なオープンソースとは言えない派閥がいる。
  完全なオープンソースのRDB(表でデータ管理するDB、表と表が関係性を持っている)を使いたいならMariaDB。
  NoSQL(キーとバリューを持つDB)はValueに値するのがJSON、キーとバリューのペアで登録していくMongoDBが有名。

- 2.基礎知識 ----------------------------------------------------------------------------------------------------
■Springスタータープロジェクトで「Lombok」使用手順
・パッケージワークスペース＞新規＞Springスタータープロジェクト
・任意の名前を指定したら＞次へ＞使用可能科目で「Lomblk」＞完了。
・Src/main/javaフォルダ下のcom.examle.demoフォルダを右クリ＞新規＞クラス
・クラス名は任意で、作成。

■@Getterと@Setter
・「Ctrl+Shift+O」でインポート編成 ※import文を自動生成してくれる。Ctrl+Sでも行ける。
・「Ctrl+O」でクイックアウトラインを表示。※Lombokでメソッドが作成された事が確認出来る。

■@data
  @Getter: 全てのフィールドに対してgetterメソッドを生成します。
  @Setter: 全ての非finalフィールドに対してsetterメソッドを生成します。
  @ToString: クラスのtoString()メソッドを生成します。
  @EqualsAndHashCode: クラスのequals()とhashCode()メソッドを生成します。
  @RequiredArgsConstructor: 全てのfinalフィールドと@NonNullが付与されたフィールドに対してコンストラクタを生成します。

■@AllArgsConstructorと@NoArgsConstructor
・コンストラクタ(全引数有りか無し)か設定できる。
  全引数有りの場合にアクセス修飾子は制限が無く、全フィールドを初期化出来る。

■Gradle(グレードル)
・ライブラリやフレームワークのバージョン管理が容易に行える。
・必要なライブラリを自動的にDLしてプロジェクトに組み込む事が出来る。
・プラグインアーキテクチャ、プラグイン利で追加機能やテスクを簡単に組み込める。
・ビルドファイル「build.gradle」に設定を記述することで必要なライブラリをDL(依存関係の管理)

■WEBサーバについて
・Apach HTTP HttpServlet：静的ファイルを配置して要求が来たら返す。※静的だけならこっちが速い。
・Tomcat：静的ファイルを返せるし、動的ファイルも返せる。

■HTTPの覚えておくメソッド
・GET	  ：データを取得（読み取り）
・POST	：新しいリソースを作成（送信）   べき等性なし：何回も処理すると、処理毎に結果がかわる。副作用がある。
・PUT	  ：既存リソースを完全に置き換え。 べき同性あり：何回処理しても同じ結果になる。例：ファイルを配置する処理を繰り返しても同じ結果。副作用なし。
・DELETE：リソースを削除
※副作用とは予測されない変更が発生すること。

■ビルドツール(ライブラリを自動取得してくれる)
・Maven：Javaの主要ライブラリはWEB上のMavenリポジトリに保管されている。Lombokも入ってる。
・Gradle：
※dependencies（依存関係）にビルドツールの内容が書かれており、コンパイル時に読み込まれる。


- 3.Spring Frameworkのコア機能 ----------------------------------------------------------------------------------------------------
■Spring Frameworkのコア機能
・DI（依存性の注入）
  ・DIコンテナ：インスタンス化機能
・AOP（アスペクト思考プログラミング） ※アスペクト＝横断的関心事
  ・中心的関心事：実現すべき機能を表すプログラム
  ・横断的関心事：本質的ではない品質や保守/運用の観点で必ず必要な機能を表すプログラム。
    →例外処理、ログ情報の画面やファイルなどへの出力、DBのトランザクション制御など。

■DIコンテナについて
・受け皿は必ずインタフェースを利用。
・インスタンスを明示的に生成しない、つまりnew不使用 ※Spring Frameworkで生成させる。
・1クラスに1インスタンスしか作らず、それをDIコンテナに配置して使いまわす仕組み。これをシングルトンという。
・利用される側のクラス宣言の上にアノテーション。
・利用する側のフィールドやコンストラクタなどなどにアノテーションを付与。
・Spring Framework起動時に対象プロジェクトのパッケージを全スキャンする(コンポーネントスキャン機能)
→スキャン後、インスタンス生成アノテーションが付与されているクラス抽出→インスタンス化。

■利用される側のインスタンス生成アノテーションは4種類
・「@Component」 ：レイヤに属さず、特定の役割を持たない場合に使用。ユーティリティやペルパークラスなど。
・「@Controller」：アプリケーション層に属し、Webリクエストのハンドラとして業務処理(ビジネスロジック)を呼び出し、レスポンスを返すクラスに付与。
・「@Service」   ：ドメイン層に属し、ビジネスロジックやトランザクション境界(開始と終了)を持つクラスに付与。よく@Transactionalと組み合わされて使用される。
・「@Repository」：インフラストラクチャ層に属し、データベースアクセス処理を行うリポジトリクラスに付与。

■利用側のクラス
・「@Autowired」：インスタンスの参照を受け取るフィールドを宣言＆フィールドにアノテーションを書く。
  読み方は「オートワイアード」

■DIを利用したプロジェクト作成
・パッケージワークスペース＞新規＞Springスタータープロジェクト
・任意の名前を指定したら＞次へ＞使用可能科目で「SpringBootDevTools」＞完了。
※SpringBootDevTools：ソースコードに変更があった場合、アプリケーションを自動的に再起動する等の機能を提供。
・Src/main/javaフォルダ下のcom.examle.demoフォルダを右クリ＞新規＞クラス
・クラス名は任意で、作成。
※Springスタータープロジェクトでは自動でプロジェクト名＋Applicationのクラスが作成される。
  このクラスの「@SpringBootApplication」アノテーションがSpringBootの起点クラスを意味する。

- Bean関係 ----------------------------------------------------------------------------------------------------
■概要
・設定クラス: @Configuration + @Bean
・Beanの自動注入: @Autowired
・複数の候補から選択: @Qualifier

■@Configuration
・クラスに追加することで設定クラスである事を示す。
・@Configurationを使うべき理由
  可読性: Bean定義がクラス内にまとまり、管理が容易。
  柔軟性: コンストラクタやメソッドの引数で他のBeanを簡単に注入可能。
  保守性: XMLに比べて変更が簡単で、Javaの型安全性も活用できる。
・@Configurationが不要な場合
  @Componentなどを使い、クラス自体に直接アノテーションを付与している場合。
  XMLで全ての設定を行っている場合。
  プログラム的にBeanを手動で登録している場合。

■@Bean
・メソッドに「@Bean」を付与すると、その返り値をクラスインスタンスとしてDIコンテナに登録。
  登録名はデフォルトでメソッド名が使用される。
  ※クラス名の先頭から大文字が2個以上並んだ場合はそのままクラス名が使われる。
  この例では、BeanはDIコンテナにtestという名前で登録される。
  DIコンテナに置いてあるBeanは依存性注入（DI）を通じて他クラスに注入できる。
  ------------------------------------------------------------------------------------------------------------------
  @Configuration
  public class AppConfig {
    
    @Bean
    public MyService test() {  // Bean名はメソッド名testで登録される。
        return new クラスA();  // クラスAというインスタンスを返す。
    }
  ------------------------------------------------------------------------------------------------------------------

■@Bean(name = "kido")
・name属性を使用すると、メソッド名ではなく任意の名前を設定できる。
  ※name属性で明示的に指定しないと、デフォルトでメソッド名で登録される。
	------------------------------------------------------------------------------------------------------------------
	@Bean(name = "kido")
	public MyService serviceA() {
		return new ServiceA();  // ServiceAのインスタンスを返す
	}
	------------------------------------------------------------------------------------------------------------------

■@Qualifier("test")
・依存性注入を行う際、複数の候補が存在する場合に特定のBeanを選択するためのアノテーション。
・@Qualifier("bean名") の形式で使用、どのBeanを注入するかを明示的に指定します。
  ------------------------------------------------------------------------------------------------------------------
	@Configuration
	public class AppConfig {
		@Bean(name = "test")
		public BusinessLogic dataLogic() {
			return new TestLogicImpl();
		}
		@Bean(name = "sample")
		public BusinessLogic viewLogic() {
			return new SampleLogicImpl();
		}
	}
	------------------------------------------------------------------------------------------------------------------
	@SpringBootApplication
	public class JavaConfigSampleApplication {
		
		/** 起動メソッド */
		public static void main(String[] args) {
			SpringApplication.run(JavaConfigSampleApplication.class, args)
					.getBean(JavaConfigSampleApplication.class).exe();
		}

		/** DI */
		@Autowired
		@Qualifier("test")
		private BusinessLogic business1; // TestLogicImplのインスタンス
		
		/** DI */
		@Autowired
		@Qualifier("sample")
		private BusinessLogic business2; // SampleLogicImplのインスタンス

		/** 実行メソッド */
		public void exe() {
			business1.doLigic();
			business2.doLigic();
		}
	}
	------------------------------------------------------------------------------------------------------------------

■インジェクション
・フィールドインジェクション (コードが完結だが非推奨)P98
	@Autowired
	private SomeService someService; //final指定不可
・セッターインジェクション
	@Autowired
	public void setSomeService(SomeService someService) {
		this.someService = someService;
・コンストラクタインジェクション
	@Autowired
	public ConstructorInjectionExample(SomeService someService) {
		this.someService = someService;
・コンストラクタインジェクション (@Autowired省略)
    //コンストラクタが１つだけの場合は「@Autowired」を省略可
	public ConstructorInjectionExample(SomeService someService) {
		this.someService = someService;
・コンストラクタインジェクション (@Autowired＆Lombok利用)
	@RequiredArgsConstructor //Lombokのアノテーション
	public class ConstructorInjectionOmitLombokExample implements Example {
		/** フィールド */
		private final SomeService someService;
		// ①コンストラクタはLombokで生成している＝コンストラクタ定義省略
		// ②Lombokで生成するコンストラクタは1個＝@Autowired省略
		// →この合わせ技でコンストラクタを完全省略できる。

※コンストラクタインジェクションが推奨される理由
・クラスの依存関係をコンストラクタの引数として明示的に定義するため
・依存関係がコンストラクタに直接示されるため、コードの可読性と保守性が向上する。
・依存関係を簡単にモックやスタブする事ができ、ユニットテストが容易になる。
・循環依存を容認せずエラーにする(AがBに、BもAに依存している場合は循環依存になる)
オマケ：SOLIDの原則、時間あったらちゃんと覚えておくと良いかも。

---------------------------------------------------------------------------
	※@RequiredArgsConstructor
	finalフィールドや@NonNullアノテーションが付けられたフィールドに対しのみ
	必要な引数を持つコンストラクタを自動的に生成
	※@NonNull
	フィールドが**nullでないことを保証するためのもの**であり
	Lombokはそのフィールドにコンストラクタを生成して、nullを防ぐために引数を要求します。
----------------------------------------------------------------------------

■起動プログラムの読み方
package com.example.demo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import com.example.demo.example.Example;

@SpringBootApplication
public class InjectionSampleApplication {
	/** 起動 */
	public static void main(String[] args) {
		SpringApplication.run(InjectionSampleApplication.class, args)
				.getBean(InjectionSampleApplication.class).exe();
	}
	/** DI */
	@Autowired
	private Example example;

	/** 実行 */
	private void exe() {
		example.run();
	}
}

@SpringBootApplication
※この名前は固有の物ではなく「プロジェクト名＋Application」で設定される。
  これがついているクラスもDIコンテナの対象に入る。
  .getBean(Beanの取得先SpringBootApplicationをリフレクションを使ってインスタンスとして指定)
  SpringBootApplicationからDIコンテナで管理されているBeanを取得する。
  ここ難しいから復習する。
・Spring Bootアプリケーションのエントリーポイントを示すアノテーション。
  中身は下記３つを組み合わせた物。
  ①@Configuration
    Springの設定クラスを示すアノテーション、Bean定義を提供するクラスとして認識される。
	このクラス内で@Beanを付与して、コンテナに登録したいBeanを定義する。
	SingletonパターンのBean定義が標準で行われる。※戻り値は1回だけインスタンス化される。
  ②@EnableAutoConfiguration
    Spring Bootの自動設定を有効にするためのアノテーション。
	アプリケーション起動時、必要な設定を自動的に行うようにする。
	クラスパスの設定やプロパティファイルをもとに自動的に必要な設定行う。
	例えば、データベース接続、メッセージング、Webサーバーなどに関する設定など。
    ぶっちゃけ開発者が直接使う事は少ない。
  ③@ComponentScan
  指定されたパッケージ内のクラスをスキャンして
  @Componentでマークされたクラス（@Component、@Service、@Repositoryなど）をコンテナに登録。

SpringApplication.run(InjectionSampleApplication.class, args)
・アプリケーションコンテキストを起動し、指定されたクラスを基にSpringBootアプリを実行する。
 「対象クラス名.class」で対象クラスのオブジェクトを取得している。

------------------------------------------------------------------------------------------------------------------

■リフレクション・Classについて
・Javaのリフレクション（反射）機能に関連するクラスです。
・全てのクラスはそのクラスのClassオブジェクトを持っている。
  オブジェクトの中身はメタデータと呼ぶ「クラス名・コンストラクタ・メソッド・フィールド等」
・オブジェクトを通じてメタデータにアクセスしたり、インスタンスを動的に生成したりできる。

①クラスオブジェクトを取得
  Class<?> clazz = InjectionSampleApplication.class;  // クラスオブジェクトを取得

②クラス名の取得
  Class<?> clazz = SomeClass.class;
  String className = clazz.getName();  // クラス名を取得
  System.out.println("クラス名: " + className);// クラス名を表示

③コンストラクタの取得
  Class<?> clazz = SomeClass.class;
  Constructor<?> constructor = clazz.getConstructor(String.class);  // 引数にStringを取るコンストラクタ
  // SomeClassのStringを引数に取るコンストラクタを取得する。

④フィールドへのアクセス
  Class<?> clazz = SomeClass.class;
  Field field = clazz.getDeclaredField("someField");  // フィールドの取得
  field.setAccessible(true);  // 非公開フィールドにアクセスする場合
  Object value = field.get(someObject);  // フィールドの値を取得
  field.set(someObject, newValue);  // フィールドの値を変更

⑤メソッドの取得と呼び出し
  Class<?> clazz = SomeClass.class;
  Method method = clazz.getMethod("someMethod", String.class);  // 引数にStringを取るメソッド
  method.invoke(someObject, "Hello");  // メソッドを呼び出す

⑥取得したコンストラクタを使いインスタンスを生成
  Class<?> clazz = SomeClass.class;
  Object instance = clazz.getDeclaredConstructor().newInstance();  // 引数なしのコンストラクタでインスタンス生成

//リフレクションの実装例
import java.lang.reflect.*;

public class ReflectionExample {

    public static class Person {
        private String name;
        private int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public void sayHello() {
            System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");
        }
    }

    public static void main(String[] args) throws Exception {
        // Personクラスのクラスオブジェクトを取得
        Class<?> clazz = Person.class;

        // コンストラクタを取得
        Constructor<?> constructor = clazz.getConstructor(String.class, int.class);

        // インスタンスを動的に生成
        Object personInstance = constructor.newInstance("John", 30);

        // メソッドsayHelloを呼び出す
        Method method = clazz.getMethod("sayHello");
        method.invoke(personInstance);  // 動的にメソッドを呼び出し
    }
}

- 4.AOP（アスペクト思考プログラミング） ----------------------------------------------------------------------------------------------------
この章は難しいので何回も読む P99～P114
■中心的関心事：メイン処理
■横断的関心事：バグが発生した際にトレースしやすくするためにログファイルに保存するために行う処理。

■アノテーション
-----------------------------------------------------------------------------------------------------------
| 用語        | 説明                                                                                       
|-------------|--------------------------------------------------------------------------------------------
| Advice      | ある特定のタイミングで実行される処理。  Adviceを記述するクラスには@Aspectを付与する。
|             | メソッドの前後や例外発生時など、処理の実行場所を指定できる。  
|             | `Before`, `After`, `Around` などの種類がある。※Aroundは最前と最後。
|             | 
|             | ■Aroundについて
|             | ※Proxyはひとつしか呼び出せないので、Around自体が判断して`Before`, Bean.method(),`After`を実行する。
|             | Beanが戻り値を返す可能性があるがその型はAroundは管理しないので、なんでも良い型(Object型インスタンス)で受け取る。
|             | Aroundで受けた後に、そのままProxyに戻してあげる。
-----------------------------------------------------------------------------------------------------------
| JoinPoint   | AOPの処理が適用される場所（メソッドの呼び出しなど）。  
|             | 通常、メソッド呼び出しのタイミングや、  
|             | メソッドの実行がJoinPointに相当する。 
-----------------------------------------------------------------------------------------------------------
| Pointcut    | 特定のJoinPointを選定するための条件。  
|             | `@Pointcut`アノテーションを使って定義され、  
|             | Adviceが適用されるタイミングを決定する。 
-----------------------------------------------------------------------------------------------------------
| Aspect      | 一連の関連するAdvice（処理）とPointcut（条件）を組み合わせたもの。  
|             | モジュール化されたクロスカッティング関心を  
|             | 表現するためのクラス。 
-----------------------------------------------------------------------------------------------------------
| Interceptor | メソッド呼び出しをインターセプトして、追加の処理を行うコンポーネント。  
|             | 一般的には`Aspect`の中で定義され、メソッドの前後で動作する。
|             | DIコンテナに置いてあるBeanは「Proxyというクラス」で覆われている。
|             | 呼び出す時はProxyを呼び出す事になるので、Proxyの前後に処理を仕込む事が出来る
-----------------------------------------------------------------------------------------------------------
| Target      | AOPによって拡張される実際のオブジェクト（クラス）。  
|             | 通常、Adviceが適用される対象となるクラスや  
|             | メソッドがTargetとなる。 
-----------------------------------------------------------------------------------------------------------

■Adviceの種類
-----------------------------------------------------------------------------------------------------------
| 種類                    | 説明                                                                                           |
|-------------------------|------------------------------------------------------------------------------------------------|
| Before Advice           | 中心的関心事が「始まる前」に、追加の処理を行います。  
|                         | 例: ログインチェック、権限チェック。  
|                         | `@Before`アノテーションで指定します。                                                  |
|-------------------------|------------------------------------------------------------------------------------------------|
| After Returning Advice  | 中心的関心事が「正常に終了した後」に、追加の処理を行います。  
|                         | 例: データベーストランザクションのコミット、成功メッセージの表示。  
|                         | `@AfterReturning`アノテーションで指定します。                                           |
|-------------------------|------------------------------------------------------------------------------------------------|
| After Throwing Advice   | 中心的関心事で「例外が発生した場合」に、追加の処理を行います。  
|                         | 例: エラーログの記録、ユーザーへのエラーメッセージ表示。  
|                         | `@AfterThrowing`アノテーションで指定します。                                             |
|-------------------------|------------------------------------------------------------------------------------------------|
| After Advice            | 中心的関心事が「終了した後」に、成功・失敗に関わらず、  
|                         | 追加の処理を行います。例: リソースの解放、後処理。  
|                         | `@After`アノテーションで指定します。                                                    |
|-------------------------|------------------------------------------------------------------------------------------------|
| Around Advice           | 中心的関心事の「前後」で、追加の処理を行います。  
|                         | 例: 処理時間の計測、トランザクションの制御など。  
|                         | `@Around`アノテーションで指定します。このタイプは最も柔軟性があります。                  |
-----------------------------------------------------------------------------------------------------------

■execution指示子 P104
・横断的関心毎を呼び出すための支持子。
  execution は、メソッドの実行をターゲットにして、アスペクトを適用する際に使うポイントカット式です。
  execution の条件にマッチするメソッドが実行される際に、指定されたアドバイス（例えば、@Before や @After）が実行されます。

・execution(戻り値型 パッケージ名.クラス名.メソッド名(引数))
  *   ：１階層のパッケージのパッケージを表す、１つ任意の引数を表す、任意の型の戻り値を表す。
  ..  ：０以上の任意のパッケージを表す、０以上の任意の引数を表す。
  +   ：クラス名の後に記述すると、そのクラスとサブクラスや実装クラスを全て表す。

  execution(* com.example.service.DemoService.*(..)) 
    // DemoService クラスの全メソッドに Advice を適用します。

  execution(* com.example.service.DemoService.select*(..)) 
    // DemoService クラスの select で始まるメソッドに Advice を適用します。

  execution(String com.example.service.DemoService.*(..)) 
    // DemoService クラスの戻り値が String 型のメソッドに Advice を適用します。

  execution(* com.example.service.DemoService.*(String, ..)) 
    // DemoService クラスの最初の引数が String 型のメソッドに Advice を適用します。

  execution(* com.example.service.*(..)) 
    // 指定されたパッケージ内のすべてのクラスのメソッドに Advice を適用します（サブパッケージは含まれません）。

  execution(* com.example.service..*(..)) 
    // com.example.service パッケージおよびそのサブパッケージに存在するすべてのクラスのメソッドに Advice を適用します。

  execution(* com.example.service.DemoService.*(..)) 
    // DemoService クラスの引数が1つの任意の型であるメソッドに Advice を適用します。

■dependencies ※依存関係
  AOPを使用するために作成したプロジェクト内、rGradleJ の設定ファイルrbuild.gradlej にAOP用の構文を追記。
  dependencies {
      implementation 'org.springframework.boot:spring-boot-starter-aop' // AOPを使用するために追加
      implementation 'org.springframework.boot:spring-boot-starter'
      developmentOnly 'org.springframework.boot:spring-boot-devtools'
      testImplementation 'org.springframework.boot:spring-boot-starter-test'
  }
  AOPのサポート: 
  spring-boot-starter-aop によって、アプリケーションにAOP機能（アスペクト指向プログラミング）を追加できます。

  基本的なSpring Boot機能: 
  spring-boot-starter で、Spring Bootアプリケーションの実行に必要なライブラリが一式揃います。

  開発環境のツール: 
  spring-boot-devtools で開発中に便利な機能（ホットリロードなど）が有効になります。

  テスト支援ツール: 
  spring-boot-starter-test で、アプリケーションのテストを効率的に行うためのツールが提供されます。

■@Transactional
・イメージ
  @Transactional：Actionクラス
  @Repository   ：DAOクラス
・DAOがDB更新後に失敗したらロールバックが必要。
  その処理がServiceクラスに@Transactionalを付与すると勝手にロールバックしてくれる(超ラク！)
  ※クラス単位やメソッド単位に付与することが出来る。


- 5.Spring MVCモデル ----------------------------------------------------------------------------------------------------
■Spring MVC
・プロジェクト作成時にSpringWebを選択することで設定できる。
・DispatcherServlet (フロントコントローラ:全リクエストを最初に受け取る) ※HttpServletを継承しているクラスっぽい？
  ここを自分で弄ることはしなくてよい。
  こいつがコントローラの【※リクエストハンドラメソッド】を呼び出す。
  ※Webアプリケーションで受け取ったHTTPリクエスト（例: GET、POST、PUT、DELETE）を処理するメソッド
  コントローラから返却されたビューを表示する役割も持つ。

・コントローラ（サブコントローラーみたいなもの）
  フロントコントローラからのリクエストに応じてビジネスロジックを呼び出す。
  その処理結果を受け取り、リクエストスコープを使いModelに格納し、「ビュー名」をフロントコントローラに返却する。
  このコントローラはたくさん(URLパターンの数分)有る、こいつは自分で作らないといけない。
  コントローラはPOJO(シンプルなJavaオブジェクト)クラスで作成。 ※何かクラスを継承するなど特殊処理をしていないクラス。
  クラスに@Controller、@RequestMappingアノテーションを付ける。

・Model
  コントローラからビューに渡す表示データを格納するオブジェクト。
  HttpServletRequestやHttpSessionと同等の機能を提供する。

・ビュー
  resources/templatesフォルダに機能別でフォルダを作成してビューを格納する。HTMLを作るテンプレ静的ファイルを置く。
  staticフォルダにはその他の静的なファイルを置く。CSSや画像ファイルなど。Tomcatがリクエストに応じて返す。
  ※ビューをstaticに入れてしまうとテンプレートエンジンに認識されないので注意。
  フロントコントローラがModelの管理するデータを受け取り、それを使いユーザに提供する画面を構築する。
  HTMLやJSONなどの形式でデータを整形し、ユーザーに提供します。

・ビジネスロジック
  データベースへのアクセス、データの取得、加工などを行う。
  この部分は開発者が設計と実装を行う。※Spring MVCとは直接関係なし。


■URLマッピング
・クラスにマッピング用のルートパスを指定(アクセスURL)
  @RequestMapping(value = "/hello")
  @RequestMapping("hello") ※最初の「/」は省略可、URLパスのみならValueも省略可。

・リクエストハンドラメソッドにGETかPOST属性指定。
  @RequestMapping(method = RequestMethod.GET)を使用。
  @RequestMapping(method = RequestMethod.POST)を使用。
  -------------------------------------------------------------
  @RequestMapping(value = "/hello", method = RequestMethod.GET)
  public String hello() {
      return "Hello, World!";
  }
  -------------------------------------------------------------
 
・リクエストハンドラメソッドに短縮型のアノテーションで属性指定。
  @GetMapping() と @POSTMapping()
  ()に任意のパスを入れれば、@RequestMappingのパス直下にパスを設定できる。
  これにより、同名メソッドで複数個作成できる。
  -------------------------------------------------------------
  @Controller
  @RequestMapping("hello")
  public class HelloViewController {

      @GetMapping("view")
      public String helloView() {
          // 戻り値は「ビュー名」を返す
          return "hello";
      }
  }
  --------------------------------------------------------------


- 6.テンプレートエンジン(Thymeleaf) ----------------------------------------------------------------------------------------------------
■ addAttribute
----------------------------------------------------------------------
  @GetMapping("model")
  public String helloView(Model model) {
    // 「Model」にデータを格納する
    model.addAttribute("msg", "タイムリーフ!!!");
    // 戻り値は「ビュー名」を返す
    return "helloThymeleaf";
  } 
----------------------------------------------------------------------
・HTTPのGETリクエストを処理するメソッドである事を示すアノテーション
  "model" は、リクエストのパス（URL）を指定していて
  http://<サーバー>/model というリクエストがこのメソッドにルーティングされる。

・public String helloView(Model model)
  Modelオブジェクトは、コントローラーからビュー(HTMLテンプレ)にデータを渡すためのインターフェース。

・model.addAttribute("msg", "タイムリーフ!!!");
  .addAttribute(String name,Object value)でテンプレートに渡すデータをモデルに追加。
  nameはViewで使う、valueは格納したいオブジェクト
  例では、キー：msg、値："タイムリーフ!!!" をセットしている。

・return "helloThymeleaf";
  ビュー名 "helloThymeleaf" を返しており、このビュー名に基づいてテンプレートを検索する。
  デフォルト検索場所は「src/main/resources/templatesフォルダ内」
  helloThymeleaf.html というファイルを探してレンダリングする（Thymeleafが使用されている場合）

■ ビューの作成
  (上記で返した戻り値「helloThymeleaf」の中身を作っている処理)
----------------------------------------------------------------------
<!DOCTYPE html>
<!-- Thymeleafを使用することを宣言する -->
<html xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <title>Hello Thymeleaf </title>
</head>
<body>
  <h1 th:text="${msg}">表示される部分</h1>
</body>
</html>
------------------------------------------------------------------------
・Thymeleafを使うための準備。
  <!DOCTYPE html>
  <html xmlns:th="http://www.thymeleaf.org">

・xmlnsとは
  XML名前空間を宣言するための属性、Thymeleafの特殊機能をHTML内で使用できるようにするための設定。
  Thymeleafのようなライブラリは独自属性(th:text, th:if)を追加するのに名前空間の宣言が必要。

・名前空間とは
  HTMLやXMLでは異なる技術やライブラリのタグや属性が衝突しないようにする名前空間という仕組みがある。
  標準的なHTMLタグ(h1やdiv)に名前空間は不要。
  th：thから始まる属性がThymeleaf固有のものであると認識される。
  このため、Thymeleafの属性は th:text のように th プレフィックスで始める。
  もし名前空間が宣言されていないと、HTMLが th:text などのカスタム属性を認識せずにエラーになる場合がある。

・http://www.thymeleaf.org
  名前空間のURI識別子(実際にアクセス出来ないURL)で、Thymeleafが提供する機能を識別するために使われる。

・<h1 th:text="${msg}">表示される部分</h1>
  <タグ名th:text="文字列">アプリ未起動時表示MSG</タグ名>   // 文字列を表示する
  <タグ名th:text="${名前}">アプリ未起動時表示MSG</タグ名>  //「設定済の名前」を指定して「値」を表示する。
  Modelに設定したペアのキー名を"${名前}"に入れると、値のオブジェクト名が表示される。

・ナチュラルテンプレート
  アプリ未実行状態の素HTMLが表示される。
  ビュー名を右クリ＞次で開く＞Webブラウザを選択。

・アプリ起動方法
  Bootダッシュボード」にて、プロジェクト名を選択して「起動」ボタン押下。
  「コンソール」で対象のアプリケーションが起動したことを確認。
  ブラウザを立ち上げ、アドレスパーにhttp://localhost:8080/hello/model と入力して表示。
  "${名前}"のオブジェクトの内容が表示され、HTMLタグの中身は上書きされるので表示されなくなる。


■ModelAndView
・Spring MVCでModelAndViewオブジェクトを使って
  データ（msg）とビュー（helloThymeleaf）を設定してレスポンスとして返しています。
  --------------------------------------------------------------
	@GetMapping("modelandview")
	public ModelAndView helloView2(ModelAndView modelAndView) {
		// データを格納する
		modelAndView.addObject("msg", "タイムリーフ!!!");
		// 画面を設定する
		modelAndView.setViewName("helloThymeleaf");
		return modelAndView;
	}
  --------------------------------------------------------------
・modelAndView.addObject("msg", "タイムリーフ!!!");

※Model と ModelAndView の違い
  addAttribute：Model        にデータを追加し、ビューだけを返す。
  addObject   ：ModelAndView にデータを追加し、ビューとデータを返す。
  条件によって異なるビューを表示させたい場合にModelAndViewを使うと細かい制御が可能。

- Thymeleafを使ってみよう -----------------------------------------------------------------------------------------------------------------------------------
■前提知識
  JSTL     ：独自タグ <c:if test="条件式">
             →HTMLとして閲覧できない。
  Thymeleaf：独自属性 <p th:if = "条件式">条件成立で表示されるMSG</p>
             →HTMLとして閲覧できるので、同じファイルを共有してデザイナーとの分業がしやすい。

■Thymeleafを使うための準備
  <!-- common.html -->
  <div th:fragment="header">

■HTMLの階層構造に影響しない属性
  <th:block> はHTML構造に出力されないため、CSSやJSのセレクタに影響を与えません。
  意味的には空のコンテナとして使用:
  このタグを追加しても、HTMLに不要な要素を追加しないので、見た目には影響を与えません。

■インライン処理
・<h1>やるぞ！[[${msg}]]</h1>
  タグではなく、メッセージ本体に変数を埋め込める。
  もしmsgに特殊文字（例えば<や>）が含まれている場合、HTMLタグだと解釈されないようにエスケープされる。
  HTMLやJavaScriptのコードに埋め込まれる文字列のセキュリティを保つために使われ、クロスサイトスクリプティング（XSS）などの攻撃を防ぐ助けになる。
  ${...}は単に式の値を評価してそのまま出力するのでHTMLの特殊文字（例：<, >, &）がそのまま表示される場合がある。

■値統合
  <h1 th:text=" '明日は' + '晴れ' + 'です。' "> HTML表示部分 </h1>
  HTMLタグ内に、th:text=""で大枠作り、''で値を囲み、+で結合する。

■値結合 (リテラル置換)
  <h1 th:text="|こんにちは！${name}さん|">HTMLで表示される部分</h1>  

■ローカル変数の宣言と代入
  <div th:with="a=1,b=2">
       <span th:text="|${a} + ${b} = ${a+b}"|>HTMLで表示される部分</span>
  </div>
  th:with="変数名=値"で変数を初期化出来る。
  変数は定義されたHTMLタグ内のみ使用可能(スコープ範囲内のみ)

■比較と等価
  <div th:text="x > 10">   xは10より大きい</div>
  <div th:text="x == 10">  xは10と等しい  </div>
  <div th:text="x != 10">  xは10ではない  </div>

■三項演算子
  <p th:text="${name} == '太郎'? 'YES' : 'NO' "></p>

■switch
- 基本構文：
  <div th:switch="${day}">
    <div th:case="1">月曜日</div>
    <div th:case="2">火曜日</div>
    <div th:case="3">水曜日</div>
    <div th:case="4">木曜日</div>
    <div th:case="5">金曜日</div>
    <div th:case="6">土曜日</div>
    <div th:case="7">日曜日</div>
    <div th:case="*">不明な曜日</div>
  </div>
  `th:case`は、`switch`内で特定のケースに一致する場合に表示される内容を指定します。
  `*`はデフォルトケースとして、どのケースにも一致しない場合に表示されます。

■条件分岐（trueの場合）
  <div th:if="${user.age >= 18}">
    成人です。
  </div>

■条件分岐（falseの場合）
  <div th:unless="${user.age >= 18}">
    未成年です。
  </div>

■条件分岐（複数条件の処理）
<div th:if="${user.age >= 20}">
  成人です。
</div>
<div th:elseif="${user.age >= 13}">
  未成年（ティーンエイジャー）です。
</div>
<div th:else>
  子供です。
</div>

■カプセル化されているフィールドの参照
  <p th:text="${user.name}">名前が入ります</p>
  <p th:text="${user.age}">年齢が入ります</p>
  publicのgetXxc()メソッドが作成されていればこの形式で参照できる。

■参照 (th:object)
  <form th:object="${user}">
    <input type="text" th:field="*{name}" />
    <input type="text" th:field="*{email}" />
  </form>
  `th:object`はフォームで使用され、モデルオブジェクト（ここでは`user`）をバインドするために使う。
  `th:field="*{name}"`のように指定すると、`user`オブジェクトの`name`フィールドが自動的にフォームにバインドされる。

■参照 (List)
  <p th:text="${list[0]}">方角</p>
  <p th:text="${list[1]}">方角</p>
  <p th:text="${list[2]}">方角</p>
  <p th:text="${list[3]}">方角</p>
  Listや配列の要素を参照するにはインデックスを利用する。

■参照 (Map)
  <p th:text="${map.tanaka.name}">名前１</p>
  <p th:text="${map['tanaka']['name']}">名前１</p> // []でアクセス
  <p th:text="${map.suzuki.name}">名前２</p>
  <p th:text="${map['suzuki']['name']}">名前２</p> // []でアクセス

■繰り返し (拡張for文みたいなの)
<div th:each="member : ${members}">
    <p>[[${member.id}]] : [[${member.name}]]</p>
</div>

■繰り返しステータス
<tr th:each="item, status : ${items}">
    <td th:text="${status.index}">Index</td>
    <td th:text="${status.count}">Count</td>
    <td th:text="${status.first}">Is First?</td>
    <td th:text="${status.last}">Is Last?</td>
    <td th:text="${status.even}">Is Even?</td>
    <td th:text="${status.odd}">Is Odd?</td>
</tr>
--------------------------------------------------------------------------------------------
ステータス変数名     | 説明
--------------------|-----------------------------------------------------------------------
index               | 0から始まるインデックスを返します。
count               | 1から始まるカウントを返します。
size                | 繰り返し処理するオブジェクトのサイズを返す。
current             | 現在のループで処理中の要素を返します。
first               | 現在の要素が最初の要素の場合にtrueを返します。
last                | 現在の要素が最後の要素の場合にtrueを返します。
even                | 現在の要素が偶数番目の場合にtrueを返します（0ベースのインデックスで判定）。
odd                 | 現在の要素が奇数番目の場合にtrueを返します（0ベースのインデックスで判定）。
--------------------|-----------------------------------------------------------------------

■ユーティリティオブジェクト (覚えきれないので使用する都度調べる)
 Javaのクラスじゃないので注意。
--------------------------------------------------------------------------------------------
カテゴリ       | 説明
---------------|----------------------------------------------------------------------------
#strings       | Stringクラスに関連する定数や共通的な処理を提供
               | 空文字定数: StringUtils.EMPTY
               | 文字列反転: StringUtils.reverse(String str)
--------------------------------------------------------------------------------------------
#numbers       | 数値（Numberクラス）に関連する定数や計算を提供
               | 最大値定数: Integer.MAX_VALUE
               | 丸め処理: Math.round(double value)
--------------------------------------------------------------------------------------------
#bools         | Booleanクラスに関連する定数や論理演算を提供
               | 定数: Boolean.TRUE, Boolean.FALSE
               | カスタムチェック: BooleanUtils.isTrue(Boolean bool)
--------------------------------------------------------------------------------------------
#dates         | Dateクラスに関連する定数や日付操作を提供
               | 現在日時取得: LocalDate.now()
               | フォーマット: "yyyy-MM-dd"
--------------------------------------------------------------------------------------------
#objects       | Objectクラスに関連する汎用的な操作を提供
               | nullチェック: ObjectUtils.isNull(Object obj)
               | オブジェクトの比較: ObjectUtils.equals(obj1, obj2)
--------------------------------------------------------------------------------------------
#arrays        | 配列（Arrayクラス）に関連する操作を提供
               | 空チェック: ArrayUtils.isEmpty(Object[] array)
               | ソート: Arrays.sort(array)
--------------------------------------------------------------------------------------------
#lists         | Listインターフェースに関連する操作や変換を提供
               | 空リスト生成: Collections.emptyList()
               | 結合操作: ListUtils.union(list1, list2)
--------------------------------------------------------------------------------------------
#sets          | Setインターフェースに関連する操作を提供
               | 空セット生成: Collections.emptySet()
               | 共通項取得: SetUtils.intersection(set1, set2)
--------------------------------------------------------------------------------------------
#maps          | Mapインターフェースに関連する操作を提供
               | 空マップ生成: Collections.emptyMap()
               | キーから値を取得: map.get(key)
--------------------------------------------------------------------------------------------

■HTMLファイルの部品化
ホームページはページの集合体。
ヘッダーとサイドバーとフッターが共通であることが多い
共通ということは、いちいちページ毎に書いてると無駄だし保守性が下がる。
そんな時に、HTMLをフラグメント化して、共通部分の記述を省くことが出来る。
----------------------------------------
<!-- common.html -->
<div th:fragment="header">
  <h1>=== [ヘッダー] ===</h1>
</div>
フラグメント(断片)は、HTMLの一部分を切り出して再利用するための機能。
ヘッダーやフッター等、複数のページで共通して使う部分を一か所にまとめることができます。
共通処理を「common.html」、共通処理を利用するファイル「main.html」に記述する。
「th:fragment="識別名称"」を指定した要素内の子要素がフラグメント対象になる。
----------------------------------------------------------------------------
<html lang～
th:fragment="base(title,content)">
<title th:replace="${title}">ベースレイアウト</title>
html要素(タグそのもの※内側も含めて)という返り値を返す関数として考える。
さらに、関数なので引数(例ではtitle,content)も受け取れてしまう。
----------------------------------------------------------------------------

6.42
layout::base(引数１,引数２)
引数１:{::title}
引数２:{::body}
→ 自分自身のtitleとbodyの中身を引数としてbase関数に渡し
HTMLを組んでもらい、戻り値でHTMLを返してもらう。
そのHTMLを使って、自分自身が持っている要素をth:replaceで変換する。

6.22の図
スタートはmainのHTML(<title>とbody)を<html>のbase関数に渡しレイアウトHTMLが弄って
その返り値のHTMLを使ってreplaceする。

----------------------------------------
<!-- main.html -->
<div th:insert="common :: header"></div>
----------------------------------------
フラグメン卜のファイル名 :: th:fragment属性の識別名称。
「th:insert」で「common.html」の中にある「header」フラグメントを挿入している。

----------------------------------------
<!-- main.html -->
<div th:replace="common :: footer"></div>
----------------------------------------
フラグメントの置換。
divタグ自体がcommon.htmlのfooterフラグメン卜に置き換わる。


■ベースレイアウト P164
・Web共通部分(ヘッダー・フッター・サイドバーなど)を1つのテンプレートとして作成すること。
  ベースレイアウトファイルは、src/main/resources/templates/layout.htmlに作成。
--------------------------------------------------------------------------------------------
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org" th:fragment="base(title, content)">
<head>
    <meta charset="UTF-8">
    <!-- ここが入れ替わる -->
    <title th:replace="${title}">ベースレイアウト</title>
</head>
<body>
    <!-- ヘッダー部分 -->
    <div style="text-align: center;">
        <h1>
            ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆<br>
            ☆           共通ヘッダー               ☆<br>
            ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
        </h1>
    </div>

    <!-- ここが入れ替わる -->
    <div style="text-align: center;" th:insert="${content}">
        内容
    </div>

    <!-- フッター部分 -->
    <div style="text-align: center;">
        <h1>
            ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆<br>
            ☆           共通フッター               ☆<br>
            ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
        </h1>
    </div>
</body>
</html>
--------------------------------------------------------------------------------------------


- 7.サーバにデータを送信する方法 -----------------------------------------------------------
■リクエストパラメータ
  ブラウザの入力画面などのビューで入力された情報は
  「リクエストパラメータ」としてリクエストに格納後、Webアプリケーションに送られる。
  ※この内容はデベロッパーツールで確認することができるので暇なときに見てみよう。

・リクエストは3つから構成される。
  ①リクエストライン
    最初の行、何をして欲しいか書く。
    「属性/対象ページ/HTTPバージョン」
    例:GET/index.html HTTP/1.1
    ※デベロッパーツールのネットワークタブのGeneralのRequestURLとRequestMethodに分解して書かれてる情報。
  ②リクエストヘッダ
    追加情報を書く。
    「User-Agent:ブラウザの種類」
    例：User-Agent:Mozilla/5.0 ※ほかにも言語やエンコーディング等も含む。
    ※デベロッパーツールのRequestHeadersのUser-Agentに書かれている情報を見ればどのブラウザからアクセスされたか見れる。
  ③リクエストボディ
    サーバに送りたいデータ本体部分を書く。
    例：フォームに入力した情報など。 ※主にPOSTメソッドで使用される。
  
・リクエストパラメータの取得
  ・@RequestParamでパラメータを1つ1つ取得可能。
    リクエストのボディやURLのクエリ部分からパラメータを取得する。
  ・SpringMVCがFormクラス内のフィールドに対し値を自動で格納する。
    リクエストパラメータをまとめて1つのオブジェクトで受け取れて実用的。
    受取時に型変換やフォーマット指定が可能。
    ※POSTの場合、ペイロードを見ればリクエストボディの内容が見れる。
      パラメータはkey(他人に見せちゃいけないやつ)とq(値)。
      GETの場合は見れないっぽい。

■HttpServletのおさらい
 param=.reguest.getParameter(パラメータ名) ※パラメータはkeyのこと。
 戻り値はString型、それ以外の場合は置換する必要がある。
 SpringMVCの場合は、型変換は自動でやってくれるので便利。

■データバインディング
 @RequestParam String val
 formタグ内のname="val"と引数名valのように名前を揃えておけば、自動で紐づけしてくれる。
 揃えない場合は省略不可なので新たに記述する内容が増える→ P177

■requiredとdefaultValue P177
・requiredは情報が必要か否か(デフォルトはTrue、省略時は引数に対する値を全て渡す必要がある)
  足りない場合は400バッドリクエストのエラーが表示される。
・defaultValueは情報が無い場合にdefaultValue="デフォルト値"で設定した値が使われる。
  requiredがfalseの時にセットで使用される。

■th:action、コンテキストパスについて
  http://sh-k.comd/appname/result
  <form action="./output.html" th:action="@{/result}" method="get"></form>
  appnameはコンテキストパス、アプリケーションを識別させるために必要。
  これをth:actionに記載する必要があるが、絶対パスではハードコーディングになり大変。
  コンテキストパスはThymeleafが知っているので、コンテキストパスから
  相対パスで"@{/result}"で./output.htmlをresultで上書きする。
  コンテキストパスはデフォルトで未設定。  
  th:hrefやth:srcも同じ仕組みで相対パスのみ記述すればOK。

■複数のリクエストパラメータ P178～
・Formクラスはビューで使うデータをまとめるためのクラスでPOJOで作る。
・「画面入力したデータname属性=Formクラスのフィールド名」にすると自動的に紐づけ(バインド)される。
・Formクラスのフィールドの型に合わせてデータ型が自動変換される。
・リクエストハンドラの引数にFormクラスを指定すると、自動的にModelに格納される＝Modelを引数に書く必要無し。
  ※これは「@ModelAttribute」アノテーションを省略している記述方法。よくわからん？？？
・Modelに格納されたFormクラスはデフォルトでリクエストスコープになるため、レスポンス後に消える。
・Modelに格納時、名前を指定しなければクラス名は小文字で始めた形(ローワーキャメルケース)で保存される。Form→form

■@DateTimeFormat P183
 @postMapping("confirm")
 public String confirmView(Model model,
 @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) @RequestParam LocalDate birth)
 デフォルトではdate=yyyy.MM.ddの形式。

■[[${name}]]
 EL式、Springの場合はSpringのEL式と呼ぶ。
 この記述でToString()メソッドが呼び出され、文字列を返す。
 Thymeleafの場合: [[${name}]]はテンプレートエンジンの構文で
 nameという変数の値をHTMLに埋め込みます。

■P184の017
データバインディング
対象：SampleFormのインスタンス → Modelに先頭小文字にしたsampleFormの名前で格納される
Modelに格納する際、@ModelAttributeが省略されている。
↓
form-backing bean
↓ 
confirmView(渡される引数) 
↓
ビューconfirmにデータバインディング後のModelの結果が入る。

■URLの設計
http://shk.com/a-service/までが共通だったとして
管理者用だったらadmin/user-info/listとか。
/user?uid=*** uidに入れて送るなど。
/user/***  ※直接値だけ送るなど。

■URLに埋め込まれた値を受け取ろう P187～
---------------------------------------------------------
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
	<meta charset="UTF-8">
	<title>URL埋め込みとボタン判別</title>
</head>
<body>
	<div>
		<!-- URLへの値埋め込み -->
		<h3><a th:href="@{/function/1}">機能-1</a></h3>
		<h3><a th:href="@{/function/2}">機能-2</a></h3>
		<h3><a th:href="@{/function/3}">機能-3</a></h3>
		<!-- 同じformタグ内にある複数ボタン -->
		<form th:action="@{/send}" method="post">
			<input type="submit" value="ボタンA" name="a">
			<input type="submit" value="ボタンB" name="b">
			<input type="submit" value="ボタンC" name="c">
		</form>
	</div>
</body>
</html>
---------------------------------------------------------
package com.example.demo.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;

@Controller
public class PathValiableController {
	// GET かつ [url：/show]
	@GetMapping("show")
	public String showView() {
		// 戻り値は「ビュー名」を返す
		return "show";
	}
	
	// GET かつ [/function/{no}]
	// ※{no}は動的に値が変わる
	@GetMapping("/function/{no}")
	public String selectFunction(@PathVariable Integer no) {
	    // 「ビュー名」の初期化
	    String view = null;
	    switch (no) {
	    case 1:
	        view = "pathvaliable/function1";
	        break;
	    case 2:
	        view = "pathvaliable/function2";
	        break;
	    case 3:
	        view = "pathvaliable/function3";
	        break;
	    }
	    // 戻り値は「ビュー名」を返す
	    return view;
	}
	
	// ▽▽▽▽▽ リスト7.18 ▽▽▽▽▽
	/** 「ボタンA」押下処理 */
	@PostMapping(value = "send", params = "a")
	public String showAView() {
	    // 戻り値は「ビュー名」を返す
	    return "submit/a";
	}

	/** 「ボタンB」押下処理 */
	@PostMapping(value = "send", params = "b")
	public String showBView() {
	    // 戻り値は「ビュー名」を返す
	    return "submit/b";
	}

	/** 「ボタンC」押下処理 */
	@PostMapping(value = "send", params = "c")
	public String showCView() {
	    // 戻り値は「ビュー名」を返す
	    return "submit/c";
	}
	// △△△△△ リスト7.18 △△△△△
}
---------------------------------------------------------

■@PathVariableとは
  ----------------------------------------------------------
  @GetMapping("/function/{no}")
	public String selectFunction(@PathVariable Integer no) {
  ----------------------------------------------------------
  URLのパス部分に含まれるデータを取得抽出するのに使う。
  動的な値をコントローラーメソッドに簡単に受け取ることが出来る。
  複数のパスパラメータや型変換にも対応可能。
  -------------------------------------------------------------
  @GetMapping("/users/{id}")
  public String getUserById(@PathVariable String id) {
      System.out.println("User ID: " + id);
      return "userDetail";
  }
  -------------------------------------------------------------
  @PathVariable String id は、URL の {id} の部分を取得。
  リクエスト: /users/123 、 id の値: "123"
  メソッドの中でidの値を使うことができます。

■params 7.18
  --------------------------------------------
	@PostMapping(value = "send", params = "a")
	public String showAView() {
	    // 戻り値は「ビュー名」を返す
	    return "submit/a";
	}
  --------------------------------------------
  @PostMappingはクラスとして考える
  ・Valueだけはデフォルトの属性で相対パス名を示す。よくValue=は省略される。 例：@PostMapping("show")
  ・paramsはメソッドを呼び出す条件でパラメータ名と呼ぶ。params = "a"
    inputタグのname="パラメータ"として送られる。
    複数パラメータの場合、配列に入れて渡すこともできる。


- 8.バリデーション -------------------------------------------------------------

■バリデーションとは
・ユーザの入力データが適切な形式であるか確認する方法。

■バリデータ
・プログラム内でデータが正しい形式になっているかチェックする機能やコードのこと。
  バリデーションを行うために必要。

■単項目チェック
 １つ１つの入力項目に対して設定するチェック機能。
 使用方法はFormクラスなどのフィールドにアノテーションを付与する。

■入力値チェック ブラウザorサーバ？
 サーバ側では絶対必須。※入力値チェックしないと攻撃される。
 ブラウザを通らなくてもサーバに対してデータを送る手段があるのでブラウザだけでは防げない。※スクレイピングなど？
 しかし、サーバのみだと正規の経路でアクセスしているクライアントの入力エラーを知らせるのにラグが発生するのでブラウザにもチェック推奨。


■Java EE標準 アノテーション
---------------------------------------------------------------------------------------------------------------------------------
アノテーション     | 説明                                                     | 使用例
-------------------|----------------------------------------------------------|--------------------------------------------------
@NotNull           | 値が `null` でないことを確認します。                     | @NotNull private String name;
@NotEmpty          | 文字列が空でない、またはコレクションが空でないことを確認 | @NotEmpty private String name;
@NotBlank          | 文字列が空白でないことを確認します。                     | @NotBlank private String name;
@Min               | 数値が指定した最小値以上であることを確認します。         | @Min(18) private int age;
@Max               | 数値が指定した最大値以下であることを確認します。         | @Max(100) private int age;
@Size              | 文字列、配列、コレクションのサイズが指定範囲内であること | @Size(min=1, max=10) private String name;
@Pattern           | 文字列が指定した正規表現に一致することを確認します。     | @Pattern(regexp="[a-zA-Z]+$") private String name;
@Email             | 文字列が有効なメールアドレス形式であることを確認します。 | @Email private String email;
@Positive          | 数値が正であることを確認します。                         | @Positive private int value;
@PositiveOrZero    | 数値が正またはゼロであることを確認します。               | @PositiveOrZero private int value;
@Negative          | 数値が負であることを確認します。                         | @Negative private int value;
@NegativeOrZero    | 数値が負またはゼロであることを確認します。               | @NegativeOrZero private int value;
-----------------------------------------------------------------------------------------------------------------------------------

■独自アノテーション
-----------------------------------------------------------------------------------------------------------------------------------
アノテーション      | 説明                                                       | 使用例
--------------------|------------------------------------------------------------|-------------------------------------------------
@Length             | 文字列の長さが指定した範囲内であることを確認します。       | @Length(min=5, max=20) private String username;
@Range              | 数値が指定した範囲内であることを確認します。               | @Range(min=1, max=100) private int score;
@CreditCardNumber   | 文字列が有効なクレジットカード番号であることを確認します。 | @CreditCardNumber private String creditCard;
-----------------------------------------------------------------------------------------------------------------------------------

■Feald.hasErrors？
 単一項目のチェックで使われ、TrueかFalseを返すが、エラー内容がわからない。

■th:errors？
 指定したフィールドに対するエラー
 各入力フィールドの直下にエラーメッセージが発生するようにした方がユーザがわかりやすい。

■Form-Backing Beanとは？ P203
  フォームで入力されたデータをサーバ送信前にForm-Backing Beanに一時保存されるイメージ。
  フォームデータを受け取るためには、フィールドとゲッターセッターを持つBeanクラスを作成する。
  ユーザーがフォームで送信したデータをクラスオブジェクトのフィールドにマッピングする。
  これにより、コントローラでデータを操作／検証／バリデーションアノテーションを使ってチェックが行える。
  
■@ModelAttribute P204
 フォームデータのバインディング
 リクエストパラメータを指定したオブジェクトに、自動的にバインド(マッピング)する役割。
 @ModelAttributeを使ってコントローラで処理したデータをビュー(JSP,Thymeleaf等)に渡せる。

■@Validated
  --------------------------------------------------------
	@PostMapping("calc")
	public String confirmView(@Validated CalcForm form,
	        BindingResult bindingResult, Model model) {
	    // 入力チェック
	    if (bindingResult.hasErrors()) {
	        return "entry"; //Trueならエラー有りで入力画面に戻す。
	    }
  --------------------------------------------------------
 @Validated CalcForm form
 @ValidatedがCalcForm型のformオブジェクトに付与されている=CalcFormオブジェクトのバリデーションが実行される。
 CalcFormオブジェクトのバリデーションとは@NotNull,@Rangeのこと。下記参照
  ---------------------------------------------------------------------------------
  @Data
  public class CalcForm {
    @NotNull(message = "左：数値が未入力です。")
    @Range(min = 1, max = 10, message = "左：{min}～{max}の数値を入力して下さい。")
    private Integer leftNum;
    @NotNull(message = "右：数値が未入力です")
    @Range(min = 1, max = 10, message = "右：{min}～{max}の数値を入力して下さい。")
    private Integer rightNum;
  }
  ---------------------------------------------------------------------------------
 バリデーションでエラーが見つかったら、BindingResultに格納される。
 CalcForm formはCalcFormクラスのローカル変数。

 ■th:field
---------------------------------------------------------------------
 	<form th:action="@{/calc}" method="post" th:object="${calcForm}">
		<div>
			<input type="text" th:field="*{leftNum}">
			+
			<input type="text" th:field="*{rightNum}">
		</div>
		<input type="submit" value="計算">
		<!-- ▽▽▽▽▽ リスト8.5 ▽▽▽▽▽ -->
		<!-- エラーを表示する -->
		<ul th:if="${#fields.hasErrors('*')}">
			<li th:each="err:${#fields.errors('*')}" th:text="${err}"></li>
		</ul>
		<!-- △△△△△ リスト8.5 △△△△△ -->
	</form>
---------------------------------------------------------------------
Formクラス のフィールドと関連付けるために、th:field 属性に {フィールド名} を指定します。
th:field 属性を使用することで、HTMLにおいて以下の属性が自動的に生成されます。
id 属性
name 属性
value 属性

--------------------------------------------------------------------------------------------------------

■相関項目チェック
 複数のフィールドを組み合わせてチェックを行う３種類の方法がある。

 1.@AssertTrue(アサートトゥルー)を利用 P212
  リクエストパラメータのバインディング(フィールドへの値の代入)
  @NotBlank,@Size等によるバリデーション(単項目チェック)
  @AssertTrueを付与したメソッドによる最終チェック的なバリデーション(相関項目チェック)
  Trueの時のみチェックOK。

2と3は難しいので今は寝かせておく。
 2.Bean Validationを利用 ※独自アノテーションを作成する必要があり難易度が高い。
 3.Spring Framework の Validatorインタフェースを実装するクラスを利用

■@AssertTrue
------------------------------------------------------
@AssertTrue(message = "パスワードが一致しません")
public boolean isSamePassword() {
    return Objects.equals(password, confirmPassword);
}
------------------------------------------------------
True：trueを返すのみ。
False：false返す＋falseをトリガーに(message = "パスワードが一致しません")を表示。



- 9. O/Rマッパー -----------------------------------------------------------------------------------------------------------
・使いこなせればDAOクラスのメソッドを殆ど書かなくてもRDBのアクセスが行えるようになる。
・1クラス：1テーブル
・1クラス：複数テーブル ※こっちはMyBatisが好まれる。
・SpringDataJDBC
・SpringDataJPA（SQLを書かずにRDBを操作するオブジェクトがいつのまにか作られている感じ）研修ではコレを使う。
・MyBatis（これがメジャーで知っておくべき）
  カスタマイズ性があるが故に、複雑なケースになったりする。


- 総合演習 ---------------------------------------------------------------------------------------------------------
■1の疑問点
・@RestController
  @Controller アノテーションと @ResponseBody アノテーションを組み合わせたもの
  @ResponseBodyとは、メソッドが返す値をHTTPレスポンスのボディとして直接書き込むことを示す。
  RESTful URLを制御するためのコントローラーを定義します。
  RESTful URL とは、REST（Representational State Transfer）アーキテクチャに基づいて設計されたURLパターン。
  本来はJSONやXMLなどを返すものですが、この場合はレスポンスとして文字列をそのままブラウザへ返します。



































