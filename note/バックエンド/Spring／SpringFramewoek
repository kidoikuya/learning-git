https://gihyo.jp/book/2024/978-4-297-14049-6/support

- 1.概要 ----------------------------------------------------------------------------------------------------
■Spring
Springとはフレームワークの集合体。
含まれているフレームワークは下記。
・Spring Boot
  開発環境を整える役割、何か開発するよ！となったらまず使う機能。
・Spring Data
  データアクセス(データベース操作)機能。
・Spring MVC
  Webアプリケーションを簡単作成する機能。
・Spring Batch
  バッチ処理(自動化処理)機能。
・Spring Security
  認証／認可・セキュリティ関連機能。
・Spring Framework
  ・DI：依存性注入の機能。
  ・AOP：アスペクト指向プログラミングの機能。
・DBについてオマケ
  MySQLはOracleが買収しちゃったので完全なオープンソースとは言えない派閥がいる。
  完全なオープンソースのRDB(表でデータ管理するDB、表と表が関係性を持っている)を使いたいならMariaDB。
  NoSQL(キーとバリューを持つDB)はValueに値するのがJSON、キーとバリューのペアで登録していくMongoDBが有名。

- 2.基礎知識 ----------------------------------------------------------------------------------------------------
■Springスタータープロジェクトで「Lombok」使用手順
・パッケージワークスペース＞新規＞Springスタータープロジェクト
・任意の名前を指定したら＞次へ＞使用可能科目で「Lomblk」＞完了。
・Src/main/javaフォルダ下のcom.examle.demoフォルダを右クリ＞新規＞クラス
・クラス名は任意で、作成。

■「Getter,Setter」作成。
・クラス外にアノテーション@Getterと@Setterを入力。
・「Ctrl+Shift+O」でインポート編成 ※import文を自動生成してくれる。Ctrl+Sでも行ける。
・「Ctrl+O」でクイックアウトラインを表示。※Lombokでメソッドが作成された事が確認出来る。

■「Getter,Setter,equals(),hashCode(),toString()」作成。
・クラス外にアノテーション@Dataを入力。
※equals()はオブジェクト比較,hashCode()オブジェクトのハッシュコード取得,toString()はオブジェクトの文字列表現を返す。

■コンストラクタ作成
・クラス外にアノテーション「@AllArgsConstructor」と「@NoArgsConstructor」※全引数有りか無しか。

■Gradle(グレードル)
・ライブラリやフレームワークのバージョン管理が容易に行える。
・必要なライブラリを自動的にDLしてプロジェクトに組み込む事が出来る。
・プラグインアーキテクチャ、プラグイン利で追加機能やテスクを簡単に組み込める。
・ビルドファイル「build.gradle」に設定を記述することで必要なライブラリをDL(依存関係の管理)

■WEBサーバについて
・Apach HTTP HttpServlet：静的ファイルを配置して要求が来たら返す。※静的だけならこっちが速い。
・Tomcat：静的ファイルを返せるし、動的ファイルも返せる。

■HTTPの覚えておくメソッド
・GET	  ：データを取得（読み取り）
・POST	：新しいリソースを作成（送信）   べき等性なし：何回も処理すると、処理毎に結果がかわる。副作用がある。
・PUT	  ：既存リソースを完全に置き換え。 べき同性あり：何回処理しても同じ結果になる。例：ファイルを配置する処理を繰り返しても同じ結果。副作用なし。
・DELETE：リソースを削除
※副作用とは予測されない変更が発生すること。

■ビルドツール(ライブラリを自動取得してくれる)
・Maven：Javaの主要ライブラリはWEB上のMavenリポジトリに保管されている。Lombokも入ってる。
・Gradle：
※dependencies（依存関係）にビルドツールの内容が書かれており、コンパイル時に読み込まれる。


- 3.Spring Frameworkのコア機能 ----------------------------------------------------------------------------------------------------
■Spring Frameworkのコア機能
・DI（依存性の注入）
  ・DIコンテナ：インスタンス化機能
・AOP（アスペクト思考プログラミング） ※アスペクト＝横断的関心事
  ・中心的関心事：実現すべき機能を表すプログラム
  ・横断的関心事：本質的ではない品質や保守/運用の観点で必ず必要な機能を表すプログラム。
    →例外処理、ログ情報の画面やファイルなどへの出力、DBのトランザクション制御など。

■DIコンテナについて
・受け皿は必ずインタフェースを利用。
・インスタンスを明示的に生成しない、つまりnew不使用 ※Spring Frameworkで生成させる。
・1クラスに1インスタンスしか作らず、それをDIコンテナに配置して使いまわす仕組み。これをシングルトンという。
・利用される側のクラス宣言の上にアノテーション。
・利用する側のフィールドやコンストラクタなどなどにアノテーションを付与。
・Spring Framework起動時に対象プロジェクトのパッケージを全スキャンする(コンポーネントスキャン機能)
→スキャン後、インスタンス生成アノテーションが付与されているクラス抽出→インスタンス化。

■利用される側のインスタンス生成アノテーションは4種類
・「@Component」 ：レイヤに属さず、特定の役割を持たない場合に使用。ユーティリティやペルパークラスなど。
・「@Controller」：アプリケーション層に属し、Webリクエストのハンドラとして業務処理(ビジネスロジック)を呼び出し、レスポンスを返すクラスに付与。
・「@Service」   ：ドメイン層に属し、ビジネスロジックやトランザクション境界(開始と終了)を持つクラスに付与。よく@Transactionalと組み合わされて使用される。
・「@Repository」：インフラストラクチャ層に属し、データベースアクセス処理を行うリポジトリクラスに付与。

■利用側のクラス
・「@Autowired」：インスタンスの参照を受け取るフィールドを宣言＆フィールドにアノテーションを書く。
  読み方は「オートワイアード」

■DIを利用したプロジェクト作成
・パッケージワークスペース＞新規＞Springスタータープロジェクト
・任意の名前を指定したら＞次へ＞使用可能科目で「SpringBootDevTools」＞完了。
※SpringBootDevTools：ソースコードに変更があった場合、アプリケーションを自動的に再起動する等の機能を提供。
・Src/main/javaフォルダ下のcom.examle.demoフォルダを右クリ＞新規＞クラス
・クラス名は任意で、作成。
※Springスタータープロジェクトでは自動でプロジェクト名＋Applicationのクラスが作成される。
  このクラスの「@SpringBootApplication」アノテーションがSpringBootの起点クラスを意味する。

- Bean関係 ----------------------------------------------------------------------------------------------------
■概要
・設定クラス: @Configuration + @Bean
・Beanの自動注入: @Autowired
・複数の候補から選択: @Qualifier

■@Configuration
・クラスに追加することで設定クラスである事を示す。
・@Configurationを使うべき理由
  可読性: Bean定義がクラス内にまとまり、管理が容易。
  柔軟性: コンストラクタやメソッドの引数で他のBeanを簡単に注入可能。
  保守性: XMLに比べて変更が簡単で、Javaの型安全性も活用できる。
・@Configurationが不要な場合
  @Componentなどを使い、クラス自体に直接アノテーションを付与している場合。
  XMLで全ての設定を行っている場合。
  プログラム的にBeanを手動で登録している場合。

■@Bean
・メソッドに「@Bean」を付与すると、その返り値をクラスインスタンスとしてDIコンテナに登録。
  登録名はデフォルトでメソッド名が使用される。
  ※クラス名の先頭から大文字が2個以上並んだ場合はそのままクラス名が使われる。
  この例では、BeanはDIコンテナにtestという名前で登録される。
  DIコンテナに置いてあるBeanは依存性注入（DI）を通じて他クラスに注入できる。
  ------------------------------------------------------------------------------------------------------------------
  @Configuration
  public class AppConfig {
    
    @Bean
    public MyService test() {  // Bean名はメソッド名testで登録される。
        return new クラスA();  // クラスAというインスタンスを返す。
    }
  ------------------------------------------------------------------------------------------------------------------

■@Bean(name = "kido")
・name属性を使用すると、メソッド名ではなく任意の名前を設定できる。
  ※name属性で明示的に指定しないと、デフォルトでメソッド名で登録される。
	------------------------------------------------------------------------------------------------------------------
	@Bean(name = "kido")
	public MyService serviceA() {
		return new ServiceA();  // ServiceAのインスタンスを返す
	}
	------------------------------------------------------------------------------------------------------------------

■@Qualifier("test")
・依存性注入を行う際、複数の候補が存在する場合に特定のBeanを選択するためのアノテーション。
・@Qualifier("bean名") の形式で使用、どのBeanを注入するかを明示的に指定します。
  ------------------------------------------------------------------------------------------------------------------
	@Configuration
	public class AppConfig {
		@Bean(name = "test")
		public BusinessLogic dataLogic() {
			return new TestLogicImpl();
		}
		@Bean(name = "sample")
		public BusinessLogic viewLogic() {
			return new SampleLogicImpl();
		}
	}
	------------------------------------------------------------------------------------------------------------------
	@SpringBootApplication
	public class JavaConfigSampleApplication {
		
		/** 起動メソッド */
		public static void main(String[] args) {
			SpringApplication.run(JavaConfigSampleApplication.class, args)
					.getBean(JavaConfigSampleApplication.class).exe();
		}

		/** DI */
		@Autowired
		@Qualifier("test")
		private BusinessLogic business1; // TestLogicImplのインスタンス
		
		/** DI */
		@Autowired
		@Qualifier("sample")
		private BusinessLogic business2; // SampleLogicImplのインスタンス

		/** 実行メソッド */
		public void exe() {
			business1.doLigic();
			business2.doLigic();
		}
	}
	------------------------------------------------------------------------------------------------------------------

■インジェクション
・フィールドインジェクション (コードが完結だが非推奨)P98
	@Autowired
	private SomeService someService; //final指定不可
・セッターインジェクション
	@Autowired
	public void setSomeService(SomeService someService) {
		this.someService = someService;
・コンストラクタインジェクション
	@Autowired
	public ConstructorInjectionExample(SomeService someService) {
		this.someService = someService;
・コンストラクタインジェクション (@Autowired省略)
    //コンストラクタが１つだけの場合は「@Autowired」を省略可
	public ConstructorInjectionExample(SomeService someService) {
		this.someService = someService;
・コンストラクタインジェクション (@Autowired＆Lombok利用)
	@RequiredArgsConstructor //Lombokのアノテーション
	public class ConstructorInjectionOmitLombokExample implements Example {
		/** フィールド */
		private final SomeService someService;
		// ①コンストラクタはLombokで生成している＝コンストラクタ定義省略
		// ②Lombokで生成するコンストラクタは1個＝@Autowired省略
		// →この合わせ技でコンストラクタを完全省略できる。

※コンストラクタインジェクションが推奨される理由
・クラスの依存関係をコンストラクタの引数として明示的に定義するため
・依存関係がコンストラクタに直接示されるため、コードの可読性と保守性が向上する。
・依存関係を簡単にモックやスタブする事ができ、ユニットテストが容易になる。
・循環依存を容認せずエラーにする(AがBに、BもAに依存している場合は循環依存になる)
オマケ：SOLIDの原則、時間あったらちゃんと覚えておくと良いかも。

---------------------------------------------------------------------------
	※@RequiredArgsConstructor
	finalフィールドや@NonNullアノテーションが付けられたフィールドに対しのみ
	必要な引数を持つコンストラクタを自動的に生成
	※@NonNull
	フィールドが**nullでないことを保証するためのもの**であり
	Lombokはそのフィールドにコンストラクタを生成して、nullを防ぐために引数を要求します。
----------------------------------------------------------------------------

■起動プログラムの読み方
package com.example.demo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import com.example.demo.example.Example;

@SpringBootApplication
public class InjectionSampleApplication {
	/** 起動 */
	public static void main(String[] args) {
		SpringApplication.run(InjectionSampleApplication.class, args)
				.getBean(InjectionSampleApplication.class).exe();
	}
	/** DI */
	@Autowired
	private Example example;

	/** 実行 */
	private void exe() {
		example.run();
	}
}

@SpringBootApplication
※この名前は固有の物ではなく「プロジェクト名＋Application」で設定される。
  これがついているクラスもDIコンテナの対象に入る。
  .getBean(Beanの取得先SpringBootApplicationをリフレクションを使ってインスタンスとして指定)
  SpringBootApplicationからDIコンテナで管理されているBeanを取得する。
  ここ難しいから復習する。
・Spring Bootアプリケーションのエントリーポイントを示すアノテーション。
  中身は下記３つを組み合わせた物。
  ①@Configuration
    Springの設定クラスを示すアノテーション、Bean定義を提供するクラスとして認識される。
	このクラス内で@Beanを付与して、コンテナに登録したいBeanを定義する。
	SingletonパターンのBean定義が標準で行われる。※戻り値は1回だけインスタンス化される。
  ②@EnableAutoConfiguration
    Spring Bootの自動設定を有効にするためのアノテーション。
	アプリケーション起動時、必要な設定を自動的に行うようにする。
	クラスパスの設定やプロパティファイルをもとに自動的に必要な設定行う。
	例えば、データベース接続、メッセージング、Webサーバーなどに関する設定など。
    ぶっちゃけ開発者が直接使う事は少ない。
  ③@ComponentScan
  指定されたパッケージ内のクラスをスキャンして
  @Componentでマークされたクラス（@Component、@Service、@Repositoryなど）をコンテナに登録。

SpringApplication.run(InjectionSampleApplication.class, args)
・アプリケーションコンテキストを起動し、指定されたクラスを基にSpringBootアプリを実行する。
 「対象クラス名.class」で対象クラスのオブジェクトを取得している。

------------------------------------------------------------------------------------------------------------------

■リフレクション・Classについて
・Javaのリフレクション（反射）機能に関連するクラスです。
・全てのクラスはそのクラスのClassオブジェクトを持っている。
  オブジェクトの中身はメタデータと呼ぶ「クラス名・コンストラクタ・メソッド・フィールド等」
・オブジェクトを通じてメタデータにアクセスしたり、インスタンスを動的に生成したりできる。

①クラスオブジェクトを取得
  Class<?> clazz = InjectionSampleApplication.class;  // クラスオブジェクトを取得

②クラス名の取得
  Class<?> clazz = SomeClass.class;
  String className = clazz.getName();  // クラス名を取得
  System.out.println("クラス名: " + className);// クラス名を表示

③コンストラクタの取得
  Class<?> clazz = SomeClass.class;
  Constructor<?> constructor = clazz.getConstructor(String.class);  // 引数にStringを取るコンストラクタ
  // SomeClassのStringを引数に取るコンストラクタを取得する。

④フィールドへのアクセス
  Class<?> clazz = SomeClass.class;
  Field field = clazz.getDeclaredField("someField");  // フィールドの取得
  field.setAccessible(true);  // 非公開フィールドにアクセスする場合
  Object value = field.get(someObject);  // フィールドの値を取得
  field.set(someObject, newValue);  // フィールドの値を変更

⑤メソッドの取得と呼び出し
  Class<?> clazz = SomeClass.class;
  Method method = clazz.getMethod("someMethod", String.class);  // 引数にStringを取るメソッド
  method.invoke(someObject, "Hello");  // メソッドを呼び出す

⑥取得したコンストラクタを使いインスタンスを生成
  Class<?> clazz = SomeClass.class;
  Object instance = clazz.getDeclaredConstructor().newInstance();  // 引数なしのコンストラクタでインスタンス生成

//リフレクションの実装例
import java.lang.reflect.*;

public class ReflectionExample {

    public static class Person {
        private String name;
        private int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public void sayHello() {
            System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");
        }
    }

    public static void main(String[] args) throws Exception {
        // Personクラスのクラスオブジェクトを取得
        Class<?> clazz = Person.class;

        // コンストラクタを取得
        Constructor<?> constructor = clazz.getConstructor(String.class, int.class);

        // インスタンスを動的に生成
        Object personInstance = constructor.newInstance("John", 30);

        // メソッドsayHelloを呼び出す
        Method method = clazz.getMethod("sayHello");
        method.invoke(personInstance);  // 動的にメソッドを呼び出し
    }
}

- 4.AOP（アスペクト思考プログラミング） ----------------------------------------------------------------------------------------------------
この章は難しいので何回も読む P99～P114
■中心的関心事：メイン処理
■横断的関心事：バグが発生した際にトレースしやすくするためにログファイルに保存するために行う処理。

■アノテーション
-----------------------------------------------------------------------------------------------------------
| 用語        | 説明                                                                                       
|-------------|--------------------------------------------------------------------------------------------
| Advice      | ある特定のタイミングで実行される処理。  Adviceを記述するクラスには@Aspectを付与する。
|             | メソッドの前後や例外発生時など、処理の実行場所を指定できる。  
|             | `Before`, `After`, `Around` などの種類がある。※Aroundは最前と最後。
|             | 
|             | ■Aroundについて
|             | ※Proxyはひとつしか呼び出せないので、Around自体が判断して`Before`, Bean.method(),`After`を実行する。
|             | Beanが戻り値を返す可能性があるがその型はAroundは管理しないので、なんでも良い型(Object型インスタンス)で受け取る。
|             | Aroundで受けた後に、そのままProxyに戻してあげる。
-----------------------------------------------------------------------------------------------------------
| JoinPoint   | AOPの処理が適用される場所（メソッドの呼び出しなど）。  
|             | 通常、メソッド呼び出しのタイミングや、  
|             | メソッドの実行がJoinPointに相当する。 
-----------------------------------------------------------------------------------------------------------
| Pointcut    | 特定のJoinPointを選定するための条件。  
|             | `@Pointcut`アノテーションを使って定義され、  
|             | Adviceが適用されるタイミングを決定する。 
-----------------------------------------------------------------------------------------------------------
| Aspect      | 一連の関連するAdvice（処理）とPointcut（条件）を組み合わせたもの。  
|             | モジュール化されたクロスカッティング関心を  
|             | 表現するためのクラス。 
-----------------------------------------------------------------------------------------------------------
| Interceptor | メソッド呼び出しをインターセプトして、追加の処理を行うコンポーネント。  
|             | 一般的には`Aspect`の中で定義され、メソッドの前後で動作する。
|             | DIコンテナに置いてあるBeanは「Proxyというクラス」で覆われている。
|             | 呼び出す時はProxyを呼び出す事になるので、Proxyの前後に処理を仕込む事が出来る
-----------------------------------------------------------------------------------------------------------
| Target      | AOPによって拡張される実際のオブジェクト（クラス）。  
|             | 通常、Adviceが適用される対象となるクラスや  
|             | メソッドがTargetとなる。 
-----------------------------------------------------------------------------------------------------------

■Adviceの種類
-----------------------------------------------------------------------------------------------------------
| 種類                    | 説明                                                                                           |
|-------------------------|------------------------------------------------------------------------------------------------|
| Before Advice           | 中心的関心事が「始まる前」に、追加の処理を行います。  
|                         | 例: ログインチェック、権限チェック。  
|                         | `@Before`アノテーションで指定します。                                                  |
|-------------------------|------------------------------------------------------------------------------------------------|
| After Returning Advice  | 中心的関心事が「正常に終了した後」に、追加の処理を行います。  
|                         | 例: データベーストランザクションのコミット、成功メッセージの表示。  
|                         | `@AfterReturning`アノテーションで指定します。                                           |
|-------------------------|------------------------------------------------------------------------------------------------|
| After Throwing Advice   | 中心的関心事で「例外が発生した場合」に、追加の処理を行います。  
|                         | 例: エラーログの記録、ユーザーへのエラーメッセージ表示。  
|                         | `@AfterThrowing`アノテーションで指定します。                                             |
|-------------------------|------------------------------------------------------------------------------------------------|
| After Advice            | 中心的関心事が「終了した後」に、成功・失敗に関わらず、  
|                         | 追加の処理を行います。例: リソースの解放、後処理。  
|                         | `@After`アノテーションで指定します。                                                    |
|-------------------------|------------------------------------------------------------------------------------------------|
| Around Advice           | 中心的関心事の「前後」で、追加の処理を行います。  
|                         | 例: 処理時間の計測、トランザクションの制御など。  
|                         | `@Around`アノテーションで指定します。このタイプは最も柔軟性があります。                  |
-----------------------------------------------------------------------------------------------------------

■execution指示子 P104
・横断的関心毎を呼び出すための支持子。
  execution は、メソッドの実行をターゲットにして、アスペクトを適用する際に使うポイントカット式です。
  execution の条件にマッチするメソッドが実行される際に、指定されたアドバイス（例えば、@Before や @After）が実行されます。

・execution(戻り値型 パッケージ名.クラス名.メソッド名(引数))
  *   ：１階層のパッケージのパッケージを表す、１つ任意の引数を表す、任意の型の戻り値を表す。
  ..  ：０以上の任意のパッケージを表す、０以上の任意の引数を表す。
  +   ：クラス名の後に記述すると、そのクラスとサブクラスや実装クラスを全て表す。

  execution(* com.example.service.DemoService.*(..)) 
    // DemoService クラスの全メソッドに Advice を適用します。

  execution(* com.example.service.DemoService.select*(..)) 
    // DemoService クラスの select で始まるメソッドに Advice を適用します。

  execution(String com.example.service.DemoService.*(..)) 
    // DemoService クラスの戻り値が String 型のメソッドに Advice を適用します。

  execution(* com.example.service.DemoService.*(String, ..)) 
    // DemoService クラスの最初の引数が String 型のメソッドに Advice を適用します。

  execution(* com.example.service.*(..)) 
    // 指定されたパッケージ内のすべてのクラスのメソッドに Advice を適用します（サブパッケージは含まれません）。

  execution(* com.example.service..*(..)) 
    // com.example.service パッケージおよびそのサブパッケージに存在するすべてのクラスのメソッドに Advice を適用します。

  execution(* com.example.service.DemoService.*(..)) 
    // DemoService クラスの引数が1つの任意の型であるメソッドに Advice を適用します。

■dependencies ※依存関係
  AOPを使用するために作成したプロジェクト内、rGradleJ の設定ファイルrbuild.gradlej にAOP用の構文を追記。
  dependencies {
      implementation 'org.springframework.boot:spring-boot-starter-aop' // AOPを使用するために追加
      implementation 'org.springframework.boot:spring-boot-starter'
      developmentOnly 'org.springframework.boot:spring-boot-devtools'
      testImplementation 'org.springframework.boot:spring-boot-starter-test'
  }
  AOPのサポート: 
  spring-boot-starter-aop によって、アプリケーションにAOP機能（アスペクト指向プログラミング）を追加できます。

  基本的なSpring Boot機能: 
  spring-boot-starter で、Spring Bootアプリケーションの実行に必要なライブラリが一式揃います。

  開発環境のツール: 
  spring-boot-devtools で開発中に便利な機能（ホットリロードなど）が有効になります。

  テスト支援ツール: 
  spring-boot-starter-test で、アプリケーションのテストを効率的に行うためのツールが提供されます。

■@Transactional
・イメージ
  @Transactional：Actionクラス
  @Repository   ：DAOクラス
・DAOがDB更新後に失敗したらロールバックが必要。
  その処理がServiceクラスに@Transactionalを付与すると勝手にロールバックしてくれる(超ラク！)
  ※クラス単位やメソッド単位に付与することが出来る。


- 5.Spring MVCモデル ----------------------------------------------------------------------------------------------------
■Spring MVC
・プロジェクト作成時にSpringWebを選択することで設定できる。
・DispatcherServlet (フロントコントローラ:全リクエストを最初に受け取る) ※HttpServletを継承しているクラスっぽい？
  ここを自分で弄ることはしなくてよい。
  こいつがコントローラの【※リクエストハンドラメソッド】を呼び出す。
  ※Webアプリケーションで受け取ったHTTPリクエスト（例: GET、POST、PUT、DELETE）を処理するメソッド
  コントローラから返却されたビューを表示する役割も持つ。

・コントローラ（サブコントローラーみたいなもの）
  フロントコントローラからのリクエストに応じてビジネスロジックを呼び出す。
  その処理結果を受け取り、リクエストスコープを使いModelに格納し、「ビュー名」をフロントコントローラに返却する。
  このコントローラはたくさん(URLパターンの数分)有る、こいつは自分で作らないといけない。
  コントローラはPOJO(シンプルなJavaオブジェクト)クラスで作成。 ※何かクラスを継承するなど特殊処理をしていないクラス。
  クラスに@Controller、@RequestMappingアノテーションを付ける。

・Model
  コントローラからビューに渡す表示データを格納するオブジェクト。
  HttpServletRequestやHttpSessionと同等の機能を提供する。

・ビュー
  resources/templatesフォルダに機能別でフォルダを作成してビューを格納する。HTMLを作るテンプレ静的ファイルを置く。
  staticフォルダにはその他の静的なファイルを置く。CSSや画像ファイルなど。Tomcatがリクエストに応じて返す。
  ※ビューをstaticに入れてしまうとテンプレートエンジンに認識されないので注意。
  フロントコントローラがModelの管理するデータを受け取り、それを使いユーザに提供する画面を構築する。
  HTMLやJSONなどの形式でデータを整形し、ユーザーに提供します。

・ビジネスロジック
  データベースへのアクセス、データの取得、加工などを行う。
  この部分は開発者が設計と実装を行う。※Spring MVCとは直接関係なし。


■URLマッピング
・クラスにマッピング用のルートパスを指定(アクセスURL)
  @RequestMapping(value = "/hello")
  @RequestMapping("hello") ※最初の「/」は省略可、URLパスのみならValueも省略可。

・リクエストハンドラメソッドにGETかPOST属性指定。
  @RequestMapping(method = RequestMethod.GET)を使用。
  @RequestMapping(method = RequestMethod.POST)を使用。
  -------------------------------------------------------------
  @RequestMapping(value = "/hello", method = RequestMethod.GET)
  public String hello() {
      return "Hello, World!";
  }
  -------------------------------------------------------------
 
・リクエストハンドラメソッドに短縮型のアノテーションで属性指定。
  @GetMapping() と @POSTMapping()
  ()に任意のパスを入れれば、@RequestMappingのパス直下にパスを設定できる。
  これにより、同名メソッドで複数個作成できる。
  -------------------------------------------------------------
  @Controller
  @RequestMapping("hello")
  public class HelloViewController {

      @GetMapping("view")
      public String helloView() {
          // 戻り値は「ビュー名」を返す
          return "hello";
      }
  }
  --------------------------------------------------------------


- 6.テンプレートエンジン(Thymeleaf) ----------------------------------------------------------------------------------------------------
■ addAttribute
----------------------------------------------------------------------
  @GetMapping("model")
  public String helloView(Model model) {
    // 「Model」にデータを格納する
    model.addAttribute("msg", "タイムリーフ!!!");
    // 戻り値は「ビュー名」を返す
    return "helloThymeleaf";
  } 
----------------------------------------------------------------------
・HTTPのGETリクエストを処理するメソッドである事を示すアノテーション
  "model" は、リクエストのパス（URL）を指定していて
  http://<サーバー>/model というリクエストがこのメソッドにルーティングされる。

・public String helloView(Model model)
  Modelオブジェクトは、コントローラーからビュー(HTMLテンプレ)にデータを渡すためのインターフェース。

・model.addAttribute("msg", "タイムリーフ!!!");
  .addAttribute(String name,Object value)でテンプレートに渡すデータをモデルに追加。
  nameはViewで使う、valueは格納したいオブジェクト
  例では、キー：msg、値："タイムリーフ!!!" をセットしている。

・return "helloThymeleaf";
  ビュー名 "helloThymeleaf" を返しており、このビュー名に基づいてテンプレートを検索する。
  デフォルト検索場所は「src/main/resources/templatesフォルダ内」
  helloThymeleaf.html というファイルを探してレンダリングする（Thymeleafが使用されている場合）

■ ビューの作成
  (上記で返した戻り値「helloThymeleaf」の中身を作っている処理)
----------------------------------------------------------------------
<!DOCTYPE html>
<!-- Thymeleafを使用することを宣言する -->
<html xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <title>Hello Thymeleaf </title>
</head>
<body>
  <h1 th:text="${msg}">表示される部分</h1>
</body>
</html>
------------------------------------------------------------------------
・Thymeleafを使うための準備。
  <!DOCTYPE html>
  <html xmlns:th="http://www.thymeleaf.org">

・xmlnsとは
  XML名前空間を宣言するための属性、Thymeleafの特殊機能をHTML内で使用できるようにするための設定。
  Thymeleafのようなライブラリは独自属性(th:text, th:if)を追加するのに名前空間の宣言が必要。

・名前空間とは
  HTMLやXMLでは異なる技術やライブラリのタグや属性が衝突しないようにする名前空間という仕組みがある。
  標準的なHTMLタグ(h1やdiv)に名前空間は不要。
  th：thから始まる属性がThymeleaf固有のものであると認識される。
  このため、Thymeleafの属性は th:text のように th プレフィックスで始める。
  もし名前空間が宣言されていないと、HTMLが th:text などのカスタム属性を認識せずにエラーになる場合がある。

・http://www.thymeleaf.org
  名前空間のURI識別子(実際にアクセス出来ないURL)で、Thymeleafが提供する機能を識別するために使われる。

・<h1 th:text="${msg}">表示される部分</h1>
  <タグ名th:text="文字列">アプリ未起動時表示MSG</タグ名>   // 文字列を表示する
  <タグ名th:text="${名前}">アプリ未起動時表示MSG</タグ名>  //「設定済の名前」を指定して「値」を表示する。
  Modelに設定したペアのキー名を"${名前}"に入れると、値のオブジェクト名が表示される。

・ナチュラルテンプレート
  アプリ未実行状態の素HTMLが表示される。
  ビュー名を右クリ＞次で開く＞Webブラウザを選択。

・アプリ起動方法
  Bootダッシュボード」にて、プロジェクト名を選択して「起動」ボタン押下。
  「コンソール」で対象のアプリケーションが起動したことを確認。
  ブラウザを立ち上げ、アドレスパーにhttp://localhost:8080/hello/model と入力して表示。
  "${名前}"のオブジェクトの内容が表示され、HTMLタグの中身は上書きされるので表示されなくなる。


■ModelAndView
・Spring MVCでModelAndViewオブジェクトを使って
  データ（msg）とビュー（helloThymeleaf）を設定してレスポンスとして返しています。
  --------------------------------------------------------------
	@GetMapping("modelandview")
	public ModelAndView helloView2(ModelAndView modelAndView) {
		// データを格納する
		modelAndView.addObject("msg", "タイムリーフ!!!");
		// 画面を設定する
		modelAndView.setViewName("helloThymeleaf");
		return modelAndView;
	}
  --------------------------------------------------------------
・modelAndView.addObject("msg", "タイムリーフ!!!");

※Model と ModelAndView の違い
  addAttribute：Model        にデータを追加し、ビューだけを返す。
  addObject   ：ModelAndView にデータを追加し、ビューとデータを返す。
  条件によって異なるビューを表示させたい場合にModelAndViewを使うと細かい制御が可能。

- Thymeleafを使ってみよう -----------------------------------------------------------------------------------------------------------------------------------
■前提知識
  JSTL     ：独自タグ <c:if test="条件式">
             →HTMLとして閲覧できない。
  Thymeleaf：独自属性 <p th:if = "条件式">条件成立で表示されるMSG</p>
             →HTMLとして閲覧できるので、同じファイルを共有してデザイナーとの分業がしやすい。

■Thymeleafを使うための準備
  <!-- common.html -->
  <div th:fragment="header">

■HTMLの階層構造に影響しない属性
  <th:block> はHTML構造に出力されないため、CSSやJSのセレクタに影響を与えません。
  意味的には空のコンテナとして使用:
  このタグを追加しても、HTMLに不要な要素を追加しないので、見た目には影響を与えません。

■インライン処理
・<h1>やるぞ！[[${msg}]]</h1>
  タグではなく、メッセージ本体に変数を埋め込める。
  もしmsgに特殊文字（例えば<や>）が含まれている場合、HTMLタグだと解釈されないようにエスケープされる。
  HTMLやJavaScriptのコードに埋め込まれる文字列のセキュリティを保つために使われ、クロスサイトスクリプティング（XSS）などの攻撃を防ぐ助けになる。
  ${...}は単に式の値を評価してそのまま出力するのでHTMLの特殊文字（例：<, >, &）がそのまま表示される場合がある。

■値統合
  <h1 th:text=" '明日は' + '晴れ' + 'です。' "> HTML表示部分 </h1>
  HTMLタグ内に、th:text=""で大枠作り、''で値を囲み、+で結合する。

■値結合 (リテラル置換)
  <h1 th:text="|こんにちは！${name}さん|">HTMLで表示される部分</h1>  

■ローカル変数の宣言と代入
  <div th:with="a=1,b=2">
       <span th:text="|${a} + ${b} = ${a+b}"|>HTMLで表示される部分</span>
  </div>
  th:with="変数名=値"で変数を初期化出来る。
  変数は定義されたHTMLタグ内のみ使用可能(スコープ範囲内のみ)

■比較と等価
  <div th:text="x > 10">   xは10より大きい</div>
  <div th:text="x == 10">  xは10と等しい  </div>
  <div th:text="x != 10">  xは10ではない  </div>

■三項演算子
  <p th:text="${name} == '太郎'? 'YES' : 'NO' "></p>

■switch
- 基本構文：
  <div th:switch="${day}">
    <div th:case="1">月曜日</div>
    <div th:case="2">火曜日</div>
    <div th:case="3">水曜日</div>
    <div th:case="4">木曜日</div>
    <div th:case="5">金曜日</div>
    <div th:case="6">土曜日</div>
    <div th:case="7">日曜日</div>
    <div th:case="*">不明な曜日</div>
  </div>
  `th:case`は、`switch`内で特定のケースに一致する場合に表示される内容を指定します。
  `*`はデフォルトケースとして、どのケースにも一致しない場合に表示されます。

■条件分岐（trueの場合）
  <div th:if="${user.age >= 18}">
    成人です。
  </div>

■条件分岐（falseの場合）
  <div th:unless="${user.age >= 18}">
    未成年です。
  </div>

■条件分岐（複数条件の処理）
<div th:if="${user.age >= 20}">
  成人です。
</div>
<div th:elseif="${user.age >= 13}">
  未成年（ティーンエイジャー）です。
</div>
<div th:else>
  子供です。
</div>

■カプセル化されているフィールドの参照
  <p th:text="${user.name}">名前が入ります</p>
  <p th:text="${user.age}">年齢が入ります</p>
  publicのgetXxc()メソッドが作成されていればこの形式で参照できる。

■参照 (th:object)
  <form th:object="${user}">
    <input type="text" th:field="*{name}" />
    <input type="text" th:field="*{email}" />
  </form>
  `th:object`はフォームで使用され、モデルオブジェクト（ここでは`user`）をバインドするために使います。
  `th:field="*{name}"`のように指定すると、`user`オブジェクトの`name`フィールドが自動的にフォームにバインドされます。

■参照 (List)
  <p th:text="${list[0]}">方角</p>
  <p th:text="${list[1]}">方角</p>
  <p th:text="${list[2]}">方角</p>
  <p th:text="${list[3]}">方角</p>
  Listや配列の要素を参照するにはインデックスを利用する。

■参照 (Map)
  <p th:text="${map.tanaka.name}">名前１</p>
  <p th:text="${map['tanaka']['name']}">名前１</p> // []でアクセス
  <p th:text="${map.suzuki.name}">名前２</p>
  <p th:text="${map['suzuki']['name']}">名前２</p> // []でアクセス

■繰り返し (拡張for文みたいなの)
<div th:each="member : ${members}">
    <p>[[${member.id}]] : [[${member.name}]]</p>
</div>

■繰り返しステータス
<tr th:each="item, status : ${items}">
    <td th:text="${status.index}">Index</td>
    <td th:text="${status.count}">Count</td>
    <td th:text="${status.first}">Is First?</td>
    <td th:text="${status.last}">Is Last?</td>
    <td th:text="${status.even}">Is Even?</td>
    <td th:text="${status.odd}">Is Odd?</td>
</tr>
--------------------------------------------------------------------------------------------
ステータス変数名     | 説明
--------------------|-----------------------------------------------------------------------
index               | 0から始まるインデックスを返します。
count               | 1から始まるカウントを返します。
size                | 繰り返し処理するオブジェクトのサイズを返す。
current             | 現在のループで処理中の要素を返します。
first               | 現在の要素が最初の要素の場合にtrueを返します。
last                | 現在の要素が最後の要素の場合にtrueを返します。
even                | 現在の要素が偶数番目の場合にtrueを返します（0ベースのインデックスで判定）。
odd                 | 現在の要素が奇数番目の場合にtrueを返します（0ベースのインデックスで判定）。
--------------------|-----------------------------------------------------------------------

■ユーティリティオブジェクト (覚えきれないので使用する都度調べる)
--------------------------------------------------------------------------------------------
カテゴリ       | 説明
---------------|----------------------------------------------------------------------------
#strings       | Stringクラスに関連する定数や共通的な処理を提供
               | 空文字定数: StringUtils.EMPTY
               | 文字列反転: StringUtils.reverse(String str)
--------------------------------------------------------------------------------------------
#numbers       | 数値（Numberクラス）に関連する定数や計算を提供
               | 最大値定数: Integer.MAX_VALUE
               | 丸め処理: Math.round(double value)
--------------------------------------------------------------------------------------------
#bools         | Booleanクラスに関連する定数や論理演算を提供
               | 定数: Boolean.TRUE, Boolean.FALSE
               | カスタムチェック: BooleanUtils.isTrue(Boolean bool)
--------------------------------------------------------------------------------------------
#dates         | Dateクラスに関連する定数や日付操作を提供
               | 現在日時取得: LocalDate.now()
               | フォーマット: "yyyy-MM-dd"
--------------------------------------------------------------------------------------------
#objects       | Objectクラスに関連する汎用的な操作を提供
               | nullチェック: ObjectUtils.isNull(Object obj)
               | オブジェクトの比較: ObjectUtils.equals(obj1, obj2)
--------------------------------------------------------------------------------------------
#arrays        | 配列（Arrayクラス）に関連する操作を提供
               | 空チェック: ArrayUtils.isEmpty(Object[] array)
               | ソート: Arrays.sort(array)
--------------------------------------------------------------------------------------------
#lists         | Listインターフェースに関連する操作や変換を提供
               | 空リスト生成: Collections.emptyList()
               | 結合操作: ListUtils.union(list1, list2)
--------------------------------------------------------------------------------------------
#sets          | Setインターフェースに関連する操作を提供
               | 空セット生成: Collections.emptySet()
               | 共通項取得: SetUtils.intersection(set1, set2)
--------------------------------------------------------------------------------------------
#maps          | Mapインターフェースに関連する操作を提供
               | 空マップ生成: Collections.emptyMap()
               | キーから値を取得: map.get(key)
--------------------------------------------------------------------------------------------

■HTMLファイルの部品化
----------------------------------------
<!-- common.html -->
<div th:fragment="header">
  <h1>=== [ヘッダー] ===</h1>
</div>

<div th:fragment="footer">
  <h1>=== [フッター] ===</h1>
</div>
----------------------------------------
 フラグメント(断片)は、HTMLの一部分を切り出して再利用するための機能。
 ヘッダーやフッター等、複数のページで共通して使う部分を一か所にまとめることができます。
 共通処理を「common.html」、共通処理を利用するファイル「main.html」に記述する。
 「th:fragment="識別名称"」を指定した要素内の子要素がフラグメント対象になる。

----------------------------------------
<!-- main.html -->
<div th:insert="common :: header"></div>
----------------------------------------
フラグメン卜のファイル名 :: th:fragment属性の識別名称。
「th:insert」で「common.html」の中にある「header」フラグメントを挿入している。

----------------------------------------
<!-- main.html -->
<div th:replace="common :: footer"></div>
----------------------------------------
フラグメントの置換。
divタグ自体がcommon.htmlのfooterフラグメン卜に置き換わる。

■ベースレイアウト

































