https://gihyo.jp/book/2024/978-4-297-14049-6/support

- 1.概要 ----------------------------------------------------------------------------------------------------
■Spring
Springとはフレームワークの集合体。
含まれているフレームワークは下記。
・Spring Boot
  開発環境を整える役割、何か開発するよ！となったらまず使う機能。
・Spring Data
  データアクセス(データベース操作)機能。
・Spring MVC
  Webアプリケーションを簡単作成する機能。
・Spring Batch
  バッチ処理(自動化処理)機能。
・Spring Security
  認証／認可・セキュリティ関連機能。
・Spring Framework
  ・DI：依存性注入の機能。
  ・AOP：アスペクト指向プログラミングの機能。
・DBについてオマケ
  MySQLはOracleが買収しちゃったので完全なオープンソースとは言えない派閥がいる。
  完全なオープンソースのRDB(表でデータ管理するDB、表と表が関係性を持っている)を使いたいならMariaDB。
  NoSQL(キーとバリューを持つDB)はValueに値するのがJSON、キーとバリューのペアで登録していくMongoDBが有名。

- 2.基礎知識 ----------------------------------------------------------------------------------------------------
■Springスタータープロジェクトで「Lombok」使用手順
・パッケージワークスペース＞新規＞Springスタータープロジェクト
・任意の名前を指定したら＞次へ＞使用可能科目で「Lomblk」＞完了。
・Src/main/javaフォルダ下のcom.examle.demoフォルダを右クリ＞新規＞クラス
・クラス名は任意で、作成。

■「Getter,Setter」作成。
・クラス外にアノテーション@Getterと@Setterを入力。
・「Ctrl+Shift+O」でインポート編成 ※import文を自動生成してくれる。Ctrl+Sでも行ける。
・「Ctrl+O」でクイックアウトラインを表示。※Lombokでメソッドが作成された事が確認出来る。

■「Getter,Setter,equals(),hashCode(),toString()」作成。
・クラス外にアノテーション@Dataを入力。
※equals()はオブジェクト比較,hashCode()オブジェクトのハッシュコード取得,toString()はオブジェクトの文字列表現を返す。

■コンストラクタ作成
・クラス外にアノテーション「@AllArgsConstructor」と「@NoArgsConstructor」※全引数有りか無しか。

■Gradle(グレードル)
・ライブラリやフレームワークのバージョン管理が容易に行える。
・必要なライブラリを自動的にDLしてプロジェクトに組み込む事が出来る。
・プラグインアーキテクチャ、プラグイン利で追加機能やテスクを簡単に組み込める。
・ビルドファイル「build.gradle」に設定を記述することで必要なライブラリをDL(依存関係の管理)

■WEBサーバについて
・Apach HTTP HttpServlet：静的ファイルを配置して要求が来たら返す。※静的だけならこっちが速い。
・Tomcat：静的ファイルを返せるし、動的ファイルも返せる。

■HTTPの覚えておくメソッド
・GET	  ：データを取得（読み取り）
・POST	：新しいリソースを作成（送信）   べき等性なし：何回も処理すると、処理毎に結果がかわる。副作用がある。
・PUT	  ：既存リソースを完全に置き換え。 べき同性あり：何回処理しても同じ結果になる。例：ファイルを配置する処理を繰り返しても同じ結果。副作用なし。
・DELETE：リソースを削除
※副作用とは予測されない変更が発生すること。

■ビルドツール(ライブラリを自動取得してくれる)
・Maven：Javaの主要ライブラリはWEB上のMavenリポジトリに保管されている。Lombokも入ってる。
・Gradle：
※dependencies（依存関係）にビルドツールの内容が書かれており、コンパイル時に読み込まれる。


- 3.Spring Frameworkのコア機能 ----------------------------------------------------------------------------------------------------
■Spring Frameworkのコア機能
・DI（依存性の注入）
  ・DIコンテナ：インスタンス化機能
・AOP（アスペクト思考プログラミング） ※アスペクト＝横断的関心事
  ・中心的関心事：実現すべき機能を表すプログラム
  ・横断的関心事：本質的ではない品質や保守/運用の観点で必ず必要な機能を表すプログラム。
    →例外処理、ログ情報の画面やファイルなどへの出力、DBのトランザクション制御など。

■DIコンテナについて
・受け皿は必ずインタフェースを利用。
・インスタンスを明示的に生成しない、つまりnew不使用 ※Spring Frameworkで生成させる。
・1クラスに1インスタンスしか作らず、それをDIコンテナに配置して使いまわす仕組み。これをシングルトンという。
・利用される側のクラス宣言の上にアノテーション。
・利用する側のフィールドやコンストラクタなどなどにアノテーションを付与。
・Spring Framework起動時に対象プロジェクトのパッケージを全スキャンする(コンポーネントスキャン機能)
→スキャン後、インスタンス生成アノテーションが付与されているクラス抽出→インスタンス化。

■利用される側のインスタンス生成アノテーションは4種類
・「@Component」 ：レイヤに属さず、特定の役割を持たない場合に使用。ユーティリティやペルパークラスなど。
・「@Controller」：アプリケーション層に属し、Webリクエストのハンドラとして業務処理(ビジネスロジック)を呼び出し、レスポンスを返すクラスに付与。
・「@Service」   ：ドメイン層に属し、ビジネスロジックやトランザクション境界(開始と終了)を持つクラスに付与。よく@Transactionalと組み合わされて使用される。
・「@Repository」：インフラストラクチャ層に属し、データベースアクセス処理を行うリポジトリクラスに付与。

■利用側のクラス
・「@Autowired」：インスタンスの参照を受け取るフィールドを宣言＆フィールドにアノテーションを書く。
  読み方は「オートワイアード」

■DIを利用したプロジェクト作成
・パッケージワークスペース＞新規＞Springスタータープロジェクト
・任意の名前を指定したら＞次へ＞使用可能科目で「SpringBootDevTools」＞完了。
※SpringBootDevTools：ソースコードに変更があった場合、アプリケーションを自動的に再起動する等の機能を提供。
・Src/main/javaフォルダ下のcom.examle.demoフォルダを右クリ＞新規＞クラス
・クラス名は任意で、作成。
※Springスタータープロジェクトでは自動でプロジェクト名＋Applicationのクラスが作成される。
  このクラスの「@SpringBootApplication」アノテーションがSpringBootの起点クラスを意味する。

- Bean関係 ----------------------------------------------------------------------------------------------------
■概要
・設定クラス: @Configuration + @Bean
・Beanの自動注入: @Autowired
・複数の候補から選択: @Qualifier

■「@Configuration」
・クラスに追加することで設定クラスである事を示す。
・@Configurationを使うべき理由
  可読性: Bean定義がクラス内にまとまり、管理が容易。
  柔軟性: コンストラクタやメソッドの引数で他のBeanを簡単に注入可能。
  保守性: XMLに比べて変更が簡単で、Javaの型安全性も活用できる。
・@Configurationが不要な場合
  @Componentなどを使い、クラス自体に直接アノテーションを付与している場合。
  XMLで全ての設定を行っている場合。
  プログラム的にBeanを手動で登録している場合。

■@Bean
・メソッドに「@Bean」を付与すると、その返り値をクラスインスタンスとしてDIコンテナに登録。
  登録名はデフォルトでメソッド名が使用される。
  この例では、BeanはDIコンテナにkidoという名前で登録される。
  DIコンテナに置いてあるBeanは依存性注入（DI）を通じて他クラスに注入できる。
  ------------------------------------------------------------------------------------------------------------------
  @Configuration
  public class AppConfig {
    
    @Bean
    public MyService test() {  // Bean名はメソッド名testで登録される。
        return new クラスA();  // クラスAというインスタンスを返す。
    }
  ------------------------------------------------------------------------------------------------------------------

■@Bean(name = "kido")
・name属性を使用すると、メソッド名ではなく任意の名前を設定できる。
  ※name属性で明示的に指定しないと、デフォルトでメソッド名で登録される。
	------------------------------------------------------------------------------------------------------------------
	@Bean(name = "kido")
	public MyService serviceA() {
		return new ServiceA();  // ServiceAのインスタンスを返す
	}
	------------------------------------------------------------------------------------------------------------------

■@Qualifier("test")
・依存性注入を行う際、複数の候補が存在する場合に特定のBeanを選択するためのアノテーション。
・@Qualifier("bean名") の形式で使用、どのBeanを注入するかを明示的に指定します。
  ------------------------------------------------------------------------------------------------------------------
	@Configuration
	public class AppConfig {
		@Bean(name = "test")
		public BusinessLogic dataLogic() {
			return new TestLogicImpl();
		}
		@Bean(name = "sample")
		public BusinessLogic viewLogic() {
			return new SampleLogicImpl();
		}
	}
	------------------------------------------------------------------------------------------------------------------
	@SpringBootApplication
	public class JavaConfigSampleApplication {
		
		/** 起動メソッド */
		public static void main(String[] args) {
			SpringApplication.run(JavaConfigSampleApplication.class, args)
					.getBean(JavaConfigSampleApplication.class).exe();
		}

		/** DI */
		@Autowired
		@Qualifier("test")
		private BusinessLogic business1; // TestLogicImplのインスタンス
		
		/** DI */
		@Autowired
		@Qualifier("sample")
		private BusinessLogic business2; // SampleLogicImplのインスタンス

		/** 実行メソッド */
		public void exe() {
			business1.doLigic();
			business2.doLigic();
		}
	}
	------------------------------------------------------------------------------------------------------------------

■インジェクション
・フィールドインジェクション (コードが完結だが非推奨)P98
	@Autowired
	private SomeService someService; //final指定不可
・セッターインジェクション
	@Autowired
	public void setSomeService(SomeService someService) {
		this.someService = someService;
・コンストラクタインジェクション
	@Autowired
	public ConstructorInjectionExample(SomeService someService) {
		this.someService = someService;
・コンストラクタインジェクション (@Autowired省略)
    //コンストラクタが１つだけの場合は「@Autowired」を省略可
	public ConstructorInjectionExample(SomeService someService) {
		this.someService = someService;
・コンストラクタインジェクション (@Autowired＆Lombok利用)
	@RequiredArgsConstructor //Lombokのアノテーション
	public class ConstructorInjectionOmitLombokExample implements Example {
		/** フィールド */
		private final SomeService someService;
		// ①コンストラクタはLombokで生成している＝コンストラクタ定義省略
		// ②Lombokで生成するコンストラクタは1個＝@Autowired省略
		// →この合わせ技でコンストラクタを完全省略できる。

※コンストラクタインジェクションが推奨される理由
・クラスの依存関係をコンストラクタの引数として明示的に定義するため
・依存関係がコンストラクタに直接示されるため、コードの可読性と保守性が向上する。
・依存関係を簡単にモックやスタブする事ができ、ユニットテストが容易になる。
・循環依存を容認せずエラーにする(AがBに、BもAに依存している場合は循環依存になる)
オマケ：SOLIDの原則、時間あったらちゃんと覚えておくと良いかも。

---------------------------------------------------------------------------
	※@RequiredArgsConstructor
	finalフィールドや@NonNullアノテーションが付けられたフィールドに対しのみ
	必要な引数を持つコンストラクタを自動的に生成
	※@NonNull
	フィールドが**nullでないことを保証するためのもの**であり
	Lombokはそのフィールドにコンストラクタを生成して、nullを防ぐために引数を要求します。
----------------------------------------------------------------------------

■起動プログラムの読み方
package com.example.demo;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import com.example.demo.example.Example;

@SpringBootApplication
public class InjectionSampleApplication {
	/** 起動 */
	public static void main(String[] args) {
		SpringApplication.run(InjectionSampleApplication.class, args)
				.getBean(InjectionSampleApplication.class).exe();
	}
	/** DI */
	@Autowired
	private Example example;

	/** 実行 */
	private void exe() {
		example.run();
	}
}

@SpringBootApplication
※この名前は固有の物ではなく「プロジェクト名＋Application」で設定される。
  これがついているクラスもDIコンテナの対象に入る。
  .getBean(Beanの取得先SpringBootApplicationをリフレクションを使ってインスタンスとして指定)
  SpringBootApplicationからDIコンテナで管理されているBeanを取得する。
  ここ難しいから復習する。
・Spring Bootアプリケーションのエントリーポイントを示すアノテーション。
  中身は下記３つを組み合わせた物。
  ①@Configuration
    Springの設定クラスを示すアノテーション、Bean定義を提供するクラスとして認識される。
	このクラス内で@Beanを付与して、コンテナに登録したいBeanを定義する。
	SingletonパターンのBean定義が標準で行われる。※戻り値は1回だけインスタンス化される。
  ②@EnableAutoConfiguration
    Spring Bootの自動設定を有効にするためのアノテーション。
	アプリケーション起動時、必要な設定を自動的に行うようにする。
	クラスパスの設定やプロパティファイルをもとに自動的に必要な設定行う。
	例えば、データベース接続、メッセージング、Webサーバーなどに関する設定など。
    ぶっちゃけ開発者が直接使う事は少ない。
  ③@ComponentScan
  指定されたパッケージ内のクラスをスキャンして
  @Componentでマークされたクラス（@Component、@Service、@Repositoryなど）をコンテナに登録。

SpringApplication.run(InjectionSampleApplication.class, args)
・アプリケーションコンテキストを起動し、指定されたクラスを基にSpringBootアプリを実行する。
 「対象クラス名.class」で対象クラスのオブジェクトを取得している。

------------------------------------------------------------------------------------------------------------------

■リフレクション・Classについて
・Javaのリフレクション（反射）機能に関連するクラスです。
・全てのクラスはそのクラスのClassオブジェクトを持っている。
  オブジェクトの中身はメタデータと呼ぶ「クラス名・コンストラクタ・メソッド・フィールド等」
・オブジェクトを通じてメタデータにアクセスしたり、インスタンスを動的に生成したりできる。

①クラスオブジェクトを取得
  Class<?> clazz = InjectionSampleApplication.class;  // クラスオブジェクトを取得

②クラス名の取得
  Class<?> clazz = SomeClass.class;
  String className = clazz.getName();  // クラス名を取得
  System.out.println("クラス名: " + className);// クラス名を表示

③コンストラクタの取得
  Class<?> clazz = SomeClass.class;
  Constructor<?> constructor = clazz.getConstructor(String.class);  // 引数にStringを取るコンストラクタ
  // SomeClassのStringを引数に取るコンストラクタを取得する。

④フィールドへのアクセス
  Class<?> clazz = SomeClass.class;
  Field field = clazz.getDeclaredField("someField");  // フィールドの取得
  field.setAccessible(true);  // 非公開フィールドにアクセスする場合
  Object value = field.get(someObject);  // フィールドの値を取得
  field.set(someObject, newValue);  // フィールドの値を変更

⑤メソッドの取得と呼び出し
  Class<?> clazz = SomeClass.class;
  Method method = clazz.getMethod("someMethod", String.class);  // 引数にStringを取るメソッド
  method.invoke(someObject, "Hello");  // メソッドを呼び出す

⑥取得したコンストラクタを使いインスタンスを生成
  Class<?> clazz = SomeClass.class;
  Object instance = clazz.getDeclaredConstructor().newInstance();  // 引数なしのコンストラクタでインスタンス生成

//リフレクションの実装例
import java.lang.reflect.*;

public class ReflectionExample {

    public static class Person {
        private String name;
        private int age;

        public Person(String name, int age) {
            this.name = name;
            this.age = age;
        }

        public void sayHello() {
            System.out.println("Hello, my name is " + name + " and I am " + age + " years old.");
        }
    }

    public static void main(String[] args) throws Exception {
        // Personクラスのクラスオブジェクトを取得
        Class<?> clazz = Person.class;

        // コンストラクタを取得
        Constructor<?> constructor = clazz.getConstructor(String.class, int.class);

        // インスタンスを動的に生成
        Object personInstance = constructor.newInstance("John", 30);

        // メソッドsayHelloを呼び出す
        Method method = clazz.getMethod("sayHello");
        method.invoke(personInstance);  // 動的にメソッドを呼び出し
    }
}

- 4.AOP（アスペクト思考プログラミング） ----------------------------------------------------------------------------------------------------
この章は難しすぎるので後で読み直す P99～P114
■中心的関心事
■横断的関心事
■CRUD
■ロギング

- 5.MVCモデル ----------------------------------------------------------------------------------------------------
■Spring MVC
・DispatcherServlet
  フロントコントローラ(全リクエストを最初に受け取る)
・コントローラ
  リクエストに応じて適切な処理を行う。
・ビュー
  画面表示処理を行う。
・Model
  コントローラからビューに渡す表示データを格納するオブジェクト。
  HttpServletRequestやHttpSessionと同等の機能を提供する。
・ビジネスロジック
  データベースへのアクセス、データの取得、加工などを行う。
  この部分は開発者が設計と実装を行う。※Spring MVCとは直接関係なし。

・Value属性
  マッピングするURLパスを指定。
  @RequestMapping(value = "/hello")
  @RequestMapping("hello") ※最初の「/」は省略可、URLパスのみならValueも省略可。
・method属性
  複数のHTTPメソッド「GETやPOSTなど」を指定。
  GETを指定： @RequestMapping(method = RequestMethod.GET)を使用。
  POSTを指定： @RequestMapping(method = RequestMethod.POST)を使用。
  ※クラスに@RequestMappingを付与時は指定しない。？？？
  ※method属性の省略
  @GetMapping ：@RequestMappingのGETリクエスト用のアノテーション、method属性無し。
  @POSTMapping：@RequestMappingのPOSTリクエスト用のアノテーション、method属性無し。



- 6.テンプレートエンジン(Thymeleaf) ----------------------------------------------------------------------------------------------------

■ addAttribute
@GetMapping("model")
public String helloView(Model model) {
  // 「Model」にデータを格納する
  model.addAttribute("msg", "タイムリーフ!!!");
  // 戻り値は「ビュー名」を返す
  return "helloThymeleaf";
} 
----------------------------------------------------------------------
・HTTPのGETリクエストを処理するメソッドである事を示すアノテーション
  "model" は、リクエストのパス（URL）を指定していて
  http://<サーバー>/model というリクエストがこのメソッドにルーティングされる。
・public String helloView(Model model)
  Modelオブジェクトは、コントローラーからビュー(HTMLテンプレ)にデータを渡すためのインターフェース。
・model.addAttribute("msg", "タイムリーフ!!!");
  .addAttribute(String name,Object value)でテンプレートに渡すデータをモデルに追加。
  nameはViewで使う、valueは格納したいオブジェクト
  例では、キー：msg、値："タイムリーフ!!!" をセットしている。
・return "helloThymeleaf";
  ビュー名 "helloThymeleaf" を返しており、このビュー名に基づいてテンプレートを検索する。
  デフォルト検索場所は「src/main/resources/templatesフォルダ内」
  helloThymeleaf.html というファイルを探してレンダリングする（Thymeleafが使用されている場合）


■ ビューの作成
  (上記で返した戻り値「helloThymeleaf」の中身を作っている処理)
----------------------------------------------------------------------
<!DOCTYPE html>
<!-- Thymeleafを使用することを宣言する -->
<html xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <title>Hello Thymeleaf </title>
</head>
<body>
  <h1 th:text="${msg}">表示される部分</h1>
</body>
</html>
------------------------------------------------------------------------
・<html xmlns:th="http://www.thymeleaf.org">
  ・xmlnsとは
    XML名前空間を宣言するための属性、Thymeleafの特殊機能をHTML内で使用できるようにするための設定。
    Thymeleafのようなライブラリは独自属性(th:text, th:if)を追加するのに名前空間の宣言が必要。
  ・名前空間とは
    HTMLやXMLでは異なる技術やライブラリのタグや属性が衝突しないようにする名前空間という仕組みがある。
    標準的なHTMLタグ(h1やdiv)に名前空間は不要。
    th：thから始まる属性がThymeleaf固有のものであると認識される。
    このため、Thymeleafの属性は th:text のように th プレフィックスで始める。
    もし名前空間が宣言されていないと、HTMLが th:text などのカスタム属性を認識せずにエラーになる場合がある。
  ・http://www.thymeleaf.org
    名前空間のURI識別子(実際にアクセス出来ないURL)で、Thymeleafが提供する機能を識別するために使われる。
・<h1 th:text="${msg}">表示される部分</h1>
  <タグ名th:text="文字列">アプリ未起動時表示MSG</タグ名>   // 文字列を表示する
  <タグ名th:text="${名前}">アプリ未起動時表示MSG</タグ名>  //「設定済の名前」を指定して「値」を表示する。
  Modelに設定したペアのキー名を"${名前}"に入れると、値のオブジェクト名が表示される。
・ナチュラルテンプレート
  アプリ未実行状態の素HTMLが表示される。
  ビュー名を右クリ＞次で開く＞Webブラウザを選択。
・アプリ起動方法
  Bootダッシュボード」にて、プロジェクト名を選択して「起動」ボタン押下。
  「コンソール」で対象のアプリケーションが起動したことを確認。
  ブラウザを立ち上げ、アドレスパーにhttp://localhost:8080/hello/model と入力して表示。
  "${名前}"のオブジェクトの内容が表示され、HTMLタグの中身は上書きされるので表示されなくなる。


■ModelAndView
・Spring MVCでModelAndViewオブジェクトを使って
  データ（msg）とビュー（helloThymeleaf）を設定してレスポンスとして返しています。
  --------------------------------------------------------------
	@GetMapping("modelandview")
	public ModelAndView helloView2(ModelAndView modelAndView) {
		// データを格納する
		modelAndView.addObject("msg", "タイムリーフ!!!");
		// 画面を設定する
		modelAndView.setViewName("helloThymeleaf");
		return modelAndView;
	}
  --------------------------------------------------------------
・modelAndView.addObject("msg", "タイムリーフ!!!");

※Model と ModelAndView の違い
  addAttribute：Model        にデータを追加し、ビューだけを返す。
  addObject   ：ModelAndView にデータを追加し、ビューとデータを返す。
  条件によって異なるビューを表示させたい場合にModelAndViewを使うと細かい制御が可能。


- Thymeleafを使ってみよう -----------------------------------------------------------------------------------------------------------------------------------

■インライン処理
・<h1>やるぞ！[[${msg}]]</h1>
タグではなく、メッセージ本体に変数を埋め込める。
  もしmsgに特殊文字（例えば<や>）が含まれている場合、HTMLタグだと解釈されないようにエスケープされる。
  HTMLやJavaScriptのコードに埋め込まれる文字列のセキュリティを保つために使われ、クロスサイトスクリプティング（XSS）などの攻撃を防ぐ助けになる。
  ${...}は単に式の値を評価してそのまま出力するのでHTMLの特殊文字（例：<, >, &）がそのまま表示される場合がある。

■値統合
  <h1 th:text=" '明日は' + '晴れ' + 'です。' "> HTML表示部分 </h1>
  HTMLタグ内に、th:text=""で大枠作り、''で値を囲み、+で結合する。

■値結合 (リテラル置換)
  <h1 th:text="|こんにちは！${name}さん|">HTMLで表示される部分</h1>  

■ローカル変数の宣言と代入
  <div th:with="a=1,b=2">
       <span th:text="|${a} + ${b} = ${a+b}"|>HTMLで表示される部分</span>
  </div>
  th:with="変数名=値"で変数を初期化出来る。
  変数は定義されたHTMLタグ内のみ使用可能(スコープ範囲内のみ)

■比較と等価
  <div th:text="x > 10">   xは10より大きい</div>
  <div th:text="x == 10">  xは10と等しい  </div>
  <div th:text="x != 10">  xは10ではない  </div>

■三項演算子
  <p th:text="${name} == '太郎'? 'YES' : 'NO' "></p>

■switch
- 基本構文：
  <div th:switch="${day}">
    <div th:case="1">月曜日</div>
    <div th:case="2">火曜日</div>
    <div th:case="3">水曜日</div>
    <div th:case="4">木曜日</div>
    <div th:case="5">金曜日</div>
    <div th:case="6">土曜日</div>
    <div th:case="7">日曜日</div>
    <div th:case="*">不明な曜日</div>
  </div>
  `th:case`は、`switch`内で特定のケースに一致する場合に表示される内容を指定します。
  `*`はデフォルトケースとして、どのケースにも一致しない場合に表示されます。

■条件分岐（trueの場合）
  <div th:if="${user.age >= 18}">
    成人です。
  </div>

■条件分岐（falseの場合）
  <div th:unless="${user.age >= 18}">
    未成年です。
  </div>

■条件分岐（複数条件の処理）
<div th:if="${user.age >= 20}">
  成人です。
</div>
<div th:elseif="${user.age >= 13}">
  未成年（ティーンエイジャー）です。
</div>
<div th:else>
  子供です。
</div>

■カプセル化されているフィールドの参照
  <p th:text="${user.name}">名前が入ります</p>
  <p th:text="${user.age}">年齢が入ります</p>
  publicのgetXxc()メソッドが作成されていればこの形式で参照できる。

■参照 (th:object)
  <form th:object="${user}">
    <input type="text" th:field="*{name}" />
    <input type="text" th:field="*{email}" />
  </form>
  `th:object`はフォームで使用され、モデルオブジェクト（ここでは`user`）をバインドするために使います。
  `th:field="*{name}"`のように指定すると、`user`オブジェクトの`name`フィールドが自動的にフォームにバインドされます。

■参照 (List)
  <p th:text="${list[0]}">方角</p>
  <p th:text="${list[1]}">方角</p>
  <p th:text="${list[2]}">方角</p>
  <p th:text="${list[3]}">方角</p>
  Listや配列の要素を参照するにはインデックスを利用する。

■参照 (Map)
  <p th:text="${map.tanaka.name}">名前１</p>
  <p th:text="${map['tanaka']['name']}">名前１</p> // []でアクセス
  <p th:text="${map.suzuki.name}">名前２</p>
  <p th:text="${map['suzuki']['name']}">名前２</p> // []でアクセス

■繰り返し















































