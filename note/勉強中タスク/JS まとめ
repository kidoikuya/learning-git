■教材URL
URL=https://shk-education-javascript.netlify.app/
URL=https://shk-education-domapi.netlify.app/
URL=https://shk-education-react.netlify.app/

■AltJS言語＝TypeScriptやCoffeeScriptのこと。
JSとは違う言語だが、最終的にはJSにコンパイルする。

■TypeScript
TypeScriptは、JavaScriptのスーパーセットであり
静的型付けを追加したプログラミング言語です。
JavaScriptのコードは有効なTypeScriptのコードでもありますが
TypeScriptは型情報を持つため、開発時にエラーを早期に発見しやすくなります。
型システム: TypeScriptは、変数や関数の引数、戻り値に型を指定できるため、
コードの可読性や保守性が向上します。
型情報により、IDE（統合開発環境）での補完機能が強化されます。
トランスパイラ: TypeScriptは、JavaScriptにコンパイルされるため、
ブラウザやNode.jsで動作することができます。
TypeScriptのコードはまずトランスパイルされ、
最終的にJavaScriptのコードになります。
主な用途: TypeScriptは、特に大規模なアプリケーションやチーム開発において、
型安全性を確保するために使用されます。
コードの予測可能性が高まり、リファクタリングが容易になります。

■Next.js＝フルスタック開発用のフレームワーク
React包括している。

■AltJS言語＝TypeScriptやCoffeeScriptのこと。

■データ型について
プリミティブ型: string、number、boolean、undefined、bigint、symbol
オブジェクト型: オブジェクト、配列、関数、null（ただし、nullは特別な意味を持つ）

■オプショナルチェインニング演算子（?.）
存在しない可能性のあるプロパティに?.を付けておけば
その先のプロパティにアクセスすることができる。
// ▼ 条件演算子を使用する場合
console.log(person.birthplace ? person.birthplace.country : undefined);
// ▼ オプショナルチェインニング演算子を使用する場合
console.log(person.birthplace?.country);

■JSとは
・基本全部オブジェクト
・変数に代入出来る
・オブジェクトのプロパティに紐づけ可
・他の関数オブジェクトに引数として渡せる(コールバック関数)
・メソッドはプロパティに紐づく関数オブジェクト。

■new or オブジェクトリテラル
・newはコンストラクタ関数を使ってオブジェクトを生成する。
-------------------------------------------------------------------------
function abc() {
  this.name = "田中";
}

const newobj = new abc(); // コンストラクタ関数を使ってオブジェクトを生成
console.log(newobj.name);  // "田中"
-------------------------------------------------------------------------
const newobj = {
  name: "田中"
};

console.log(newobj.name);  // "田中"
-------------------------------------------------------------------------

・newを使わない場合どうなるのか

-new使用時------------------------------------------------------------------------
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const person1 = new Person("田中", 30);  // コンストラクタ関数の戻り値は新しく生成されたオブジェクト
console.log(person1.name);  // "田中"
console.log(person1.age);   // 30

-new不使用------------------------------------------------------------------------
function Person(name, age) {
  this.name = name;
  this.age = age;
}

const person1 = Person("田中", 30);  // new不使用なのでthisはグローバルオブジェクトを指す
console.log(person1);       // undefined（戻り値がないため）
console.log(person1.name);  // TypeError: Cannot read properties of undefined (reading 'name')
console.log(globalThis.name); //グローバルオブジェクトを利用して出力
-------------------------------------------------------------------------






■関数の呼び出し型
・関数定義＝thisを持っている。
function abc(){
    console.log("------\n",this,"------\n");    
}

・アロー関数式＝thisを持っていない。
const abc = ()=>{
    console.log("------\n",this,"------\n");
}

・単独で呼び出す→グローバルオブジェクト
  abc();
------------------------------------------------------------------
・オブジェクトのメソッドとして呼び出す→呼び出し元のオブジェクト
const obj = {
    abc:abc,
}
obj.abc();
------------------------------------------------------------------
・new演算子から呼び出す→新しく作成されたオブジェクト
const newobj = new abc();
※空のabc
------------------------------------------------------------------
上記３つ、それぞれでthisの参照先が変わる。
※ただし、アロー関数式はthisを持たないので別。

■クロージャ
インナーのスコープ内で見つからない変数をアウターのスコープに探しに行く。
この際、アウターのどこに変数が格納されているかを(変数作成時)に記憶しておくのがクロージャ
Pythonのデコレータと同じ考え、@が出てきたら思い出そう。

■高階関数
他の関数を引数として受け取ったり、結果として関数を返したりする関数のこと。
高階関数は、プログラミングにおける柔軟な設計を可能にし
コードの再利用性や抽象度を高めるためによく使われます。
高階関数の特徴＝引数として関数を取る、関数そのものを他の関数の引数として渡すことができる。
関数が別の関数を返すことができる。

■グローバルオブジェクト
実行環境: ブラウザ = window
実行環境: node.js  = global
EC2020からはglobalThisを使えば実行環境問わずに参照可能。

■thisについて
・前提としてJSはthisを省略できない。
  thisが主略されると自スコープのオブジェクト内のプロパティではなく
  外側のスコープにプロパティを探しに行ってしまう。
・3.new演算子から呼び出す function有り
JSにクラスは無い。
関数はコンストラクタみたいなもの。
newで引数を渡すと、this(オブジェクト)のフィールドに引数が代入される。
returnが書かれていないけど、thisの値が返されるので
newを入れる変数には、thisの返り値が入る。

・アロー関数式 function無し
thisを持たないので、外側スコープにthisという変数を探しにいく。
つまり、メソッドとしてthisが使えない＝メソッドが意味をなさない。
だから、アロー関数式は使用しない。
new演算子からもthisがないのでコンパイルエラーになる。

■分割代入のわかりにくい所
指定したプロパティに対してのみ代入されるため
ネストしている場合は、指定外には代入されないし
そもそも変数として宣言すらされないから
console.logを叩いてもundefrinedすら表示されない。

■setTimeoutは予約
引数(関数名,LIMIT)でLIMIT後に関数を実行する。戻り値は予約ID
このIDはキャンセルする時に使う。

■プログラムを書く時のコツ
※とにかく書く、大きな塊のコードを書いてみる、機能追加してみるとか。
※分解して考える、紙に書いて整理する。
・機能設計：必要機能を箇条書きで書き出す。
・基本設計：１つの機能に対して具体的に実現する方法を考える
  画面ベースで処理の流れや状態推移等を考える。
・詳細設計：クラス図を書いて全体的な構成を考える。
・コーディング開始
・UMLで図や手法等のドキュメントをまとめる(コーディングより時間使うっぽい)

■vite
WebpackはJSで書かれているのでnode.jsが必要。
似たような機能を使える10倍速いvite(ヴィート)がある。

■JSON
JSのオブジェクト表現

■モジュール
※https://www.tohoho-web.com/ex/npm.html
node_modulesフォルダに必要ファイルが格納される。
関連しているパッケージが多いので重たい。
だから、githubで公開されているプログラムはnode_modulesが入ってない？
cloneした後に、自分でインストールコマンド(依存関係を一括対応してくれる)を入れる。
$ ls -l
-rw-rw-r--.  1 taro taro   265 Jan 18 01:41 package.json
$ npm install

node.jsが提供するパッケージインストールコマンド
・npm install パッケージ --オプション
--no-save
package.json に書き込まない場合に指定します。npm4 までは package.json に書き込まないのがデフォルトでしたが、npm5 からは --save がデフォルトとなりました。
--save
依存パッケージの場合に指定します。package.json の dependencies に記録されます。このパッケージを誰かが npm install したときに依存パッケージとしてインストールされます。
--save-optional
依存はするけれど必須ではないパッケージの場合に指定します。package.json の optionalDependencies に記録されます。npm install でインストールされますが、インストールに失敗してもスルーされます。
--save-dev
テストツールなど、開発者が使用するパッケージの場合に指定します。package.json の devDependencies に記録されます。このパッケージを npm install しても、インストールされません。ただし、パッケージを Git から clone して npm install した場合は開発者とみなされ、インストールされます。
package.json に記述されたパッケージを再度インストールするには、package.json が存在するディレクトリで下記を実行します。

■ライブラリとフレームワークの違い
ライブラリ:
特定の機能やタスクを実行するための再利用可能なコードの集まり。
開発者が必要に応じてライブラリの機能を呼び出して利用します。
例: jQuery、Lodash、Apache Commons など。

フレームワーク:
アプリケーションの構造や設計を提供する骨組みです。
開発者はフレームワークが定めたルールやガイドラインに従ってアプリケーションを構築します。
堅牢な開発が出来るので、大規模開発でよく利用される。
例: Spring、Django、Ruby on Rails など。

■非同期通信
varを使ってるかも。
フェッチが出てきてる、




















